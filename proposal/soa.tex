\section{Namespaces in OCaml: state of the art}

\subsection{Linking formalism}

First of all, it can be interesting to formalize what is a correctly linked
program. This mechanism will be different starting from 4.02, then it is
interesting to understand how the changes will affect the linked programs.

We will suppose the typechecking is always correct. Lets assume a program is
simply an ordered set $Pr$ of compilation units $\{C_0$, .. $C_n\}$. We suppose
$deps(C)$ the set of compilation units on which is dependent C. Then, we express
the dependency order by $\prec$, whereas $A \prec B$ means $B$ has a dependency
on $A$. The dependency is a strict order relationship, and as a result it is
transitive and not reflexive. Then:

$$A \prec B \leftrightarrow A \in deps(B)$$

%% Another property is the dependencies propagation:

%% \begin{equation}
%%   A \prec B \rightarrow deps(A) \subseteq deps(B)
%%   \label{propagate}
%% \end{equation}

The load path $LP$ is the set of paths $\{P_0, .., P_m\}$ where are stored
compilation units that can be used at link time. Then, we suppose $compunit(P)$
the set of available compilation units in the path $P$. We define $\oplus$ as
the merge operation of two sets ($S_1$ and $S_2$):

$$S_1 \oplus S_2 = S_1 \cup (S_2 - S_1 \cap S_2) $$

Then, the set of available compilation units $Cs$ from the load path at the path
$P_k$ is: 

\begin{equation}
Cs(P_m) = Cs(m-1) \oplus compunit(P-m) \text{ and } Cs(P_0) = compunit(P_0)
\label{merge}
\end{equation}

Morally, it is a \emph{fold left application} of $\oplus$ over the load path. We
will use it as $compunits(LP)$.

Let $M_i$ the source file for $C_i$. We assume $deps(\_)$ is also available for
source files, and returns the necessary compilation units ($deps(M_i) =
deps(C_i)$). Then $compile(M_i)$ is a predicate indicating if the source file
can be compiled (and $C_i$ its result), and

\begin{equation}
compile(M_i) \rightarrow deps(M_i) \subseteq compunits(LP)
\label{compile}
\end{equation}

As a result, we can express a correctly linked program as:

\begin{multline}
Pr ::= \{ C_0, .., C_n ~|~ \forall i \in [1; n], ~deps(C_i) \subseteq \{ C_0, ..,
    C_{i-1} \} \land deps(C_0) = \emptyset \}\\
    \text{whereas} ~ LP = \{ P_0, .., P_m \}~and~\forall i \in [0; n], C_i \in compunits(LP)
\label{linkable}
\end{multline}


On a side note, we can use the following predicate $recompile(C)$, that
indicates if a file has to be recompiled in that case. Morally, if one must be
recompiled, then the recompilation is propagated over those that depends on it:

\begin{equation}
  \forall C \in deps(X), recompile(C) \rightarrow recompile(X)
\label{recompile}
\end{equation}

\subsection{Prior 4.02.0}

In the current stable version (4.01.0), there is no namespace solution. The only
possibility is aliasing modules into a big one, which is a kind of
\emph{wrapper} module. A typical ``namespace module'' is simply a \texttt{.ml}
that only contains multiple:

\begin{OCaml}
module List = Mystd_List
\end{OCaml}

It has multiple bad properties:
\begin{enumerate}
  \item It is a bottleneck for dependencies: when one of the aliased module is
    recompiled, the wrapper must be recompiled, and in fact every module that
    depends on it must be compiled again (because of (\ref{recompile})).
  \item When using it as a namespace, every module aliased in it has to be
    linked: this kind of module can lead to build huge executables. Even if one
    of the alias is not used, it must be linked with the program since the
    wrapper is dependent on it. It is expressed above by the constraint $
    \forall i \in [1; n], ~deps(C_i) \subseteq \{ C_0, .., C_{i-1} \}$ in
    (\ref{linkable}).
  \item It is not extensible: Some would want to extend ``a posteriori'' a
    namespace they are using to add new modules or redefine them. The usage of
    modules means it is restricted by their semantics.
\end{enumerate}

Another possible solution is \emph{packing} the modules to make them appear as
if they were part of a namespace. The idea is to take every compilation unit,
and copy them into a single one that acts as a wrapper. As a result, using a
namespace is simply linking this huge compilation unit. It is completely managed
by the build system, and as a consequence the dependencies can be hard to
compute since the wrapper does not have a source file.

The last solution is simply prefixing modules' name to be unique, without a
\emph{wrapper} to access them: only necessary modules are linked, however it can
be a little painful for the user to use those long names.

\subsection{Toward 4.02.0}

The next version of OCaml changes a bit the link process, by adding an option
\texttt{-no-alias-deps} that changes its semantics by making a difference
between \emph{aliases} and dependencies. It introduces the concept of weak
dependencies. Formally, it adds a new predicate $weakdeps(C)$ for each
compilation units. If the compilation unit $C$ aliases another compilation unit
(\texttt{module X = Y}) and is compiled using \texttt{-no-alias-deps}, then

$$\texttt{module~X = Y} \rightarrow Y \notin deps(C) \land Y \in weakdeps(C)$$ 

If $X$ is used (as qualifier, opened or used as argument of a functor or as
first-class argument), $Y$ is no longer part of weak dependencies but becomes a
srong one, then $\forall C, weakdeps(C) \cap deps(C) = \emptyset$. Moreover,
$weakdeps(C)$ is transitive:

\begin{multline} \\
\forall X, Y, Z \text{ fresh module names}, \\ A \prec B \\
\land X \in weakdeps(A) \\ 
\land \text{``module Y = X''} \in A \\
\land \text{``module Z = Y''} \in B \\
\rightarrow X \in weakdeps(B)
\end{multline}

In other word, aliasing a weak dependency of another compilation unit makes it a
weak dependency in the current environment (until it is used). The correctly
linked program equation does not change in this configuration, which then
implies some important properties:
\begin{itemize}
\item An unused alias does not have to be \emph{linked} for the program to be correct;
\item An unused alias does not have to be \emph{present} to compile.
\item A side effect of this option is that there is no bottleneck when a
  recompilation is needed, since the alias is propagated until it is
  used. However, it needs a strong build system to discover such propagation.
\end{itemize}

Another option added is the \texttt{-open}: it takes a module name and opens it
directly (it adds the opening statement in the AST).

Finally, the \texttt{-o} has been modified: the compilation unit name is now the
same as the filename given to the option (actually, only the left part before
the first ``.'').

\subsection{Example and experimentation}

Using those features, it is possible to simulate some kind of ``namespaces'' in
OCaml. Here is a complete example of how it works.

We are going to make a namespace Ns, which will contain three modules A, B and
C. Then Ns is simply a module that contains only aliases (the code of this
example is available in the same repository as this proposal):

\begin{OCaml}
(* ns.ml *)

module A = Ns_a
module B = Ns_b
module C = Ns_c
\end{OCaml}

Then, we define our modules:

\begin{OCaml}
(* a.ml *)
let print_from_A () = print_endline ``Hello from A!''

(* b.ml *)
let print_from_B () = print_endline ``Hello from B!''

(* c.ml *)
let x = ``lorem ipsum ...'' (* ~15000 characters long *)

let print_from_C () =
  A.print_from_A ();
  B.print_from_B ();
  Printf.printf ``Ouch! from C:\n %s\n'' x
\end{OCaml}

We use our library into a \texttt{main.ml} file:

\begin{OCaml}
open Ns

let _ = 
  A.print_from_A ();
  B.print_from_B ()
\end{OCaml}

As you can notice, those files are not using the same name as defined in
ns.ml. Now, here is the command line to compile our new namespace and the
program using it. We will explain it step by step:

%% \begin{verbatim}
%% 1) ocamlc -c -no-alias-deps ns.ml
%% 2) ocamlc -c -open Std -o ns_a.cmo -c a.ml
%% 3) ocamlc -c -open Std -o ns_b.cmo -c b.ml
%% 4) ocamlc -c -open Std -o ns_c.cmo -c b.ml
%% 5) ocamlc -a -o ns.cma ns.cmo ns_a.cmo ns_b.cmo ns_c.cmo
%% 6) ocamlc -o prog.byte ns.cma main.ml
%% \end{verbatim}

\begin{verbatim}
$ ocamlc -c -no-alias-deps ns.ml
File "_none_", line 1:
Warning 49: no cmi file was found in path for module Ns_a
File "_none_", line 1:
Warning 49: no cmi file was found in path for module Ns_b
File "_none_", line 1:
Warning 49: no cmi file was found in path for module Ns_c
\end{verbatim}

\texttt{ns.ml} is first compiled using the \texttt{-no-alias-deps} option. The
\texttt{.cmo} can be compiled without even needing the .cmis of Ns\_a, Ns\_b and
Ns\_c, as soon as they can be given at link time \textbf{if they are ever
  used}.

\begin{verbatim}
$ ocamlc -c -open Ns -o ns_a.cmo a.ml
$ ocamlc -c -open Ns -o ns_b.cmo b.ml
$ ocamlc -c -open Ns -o ns_c.cmo c.ml
\end{verbatim}

The three files are compiled, and their result will be the original name
prefixed by ``ns\_''. It matches the names given in \texttt{ns.ml}. One can
notice the \texttt{-open Ns}: it is a trick to be able to refer directly to the
other modules from Ns, and it allows ocamldep not to discover the dependency to
\texttt{ns.cmo}. ocamldep will then look for the ``unprefixed'' sources. 

\begin{verbatim}
$ ocamlc -a -o ns.cma ns.cmo ns_a.cmo ns_b.cmo ns_c.cmo
\end{verbatim}

A library is created for our namespace. It is not mandatory, but it will help to
link only the compilation units that are \emph{strong dependencies}.

\begin{verbatim}
$ ocamlc -c main.ml
$ ocamlc -o prog ns.cma main.cmo
\end{verbatim}

Finally, \texttt{main.ml} is compiled using this namespace.

It does work, but it does not tell too much how it changes the current
behavior. We will compare by creating a namespace without using the
\texttt{-no-alias-deps} option. It simply changes the order of compilation, and
\texttt{-open Ns} won't be usable since it cannot be compiled before the
compilation units it aliases.

\begin{verbatim}
Size of executables generated using -no-alias-deps and -pack:
prog: 16392 bytes.
prog.opt: 199309 bytes.
prog_pack: 127343 bytes.     //only in bytecode

Size of executables generated without -no-alias-deps:
prog: 127399 bytes.
prog.opt: 485852 bytes.
\end{verbatim}

As we can notice, since our main program does not use the module C of
``namespace'' Ns, it is never linked when using \texttt{-no-alias-deps}. We can
notice the difference in terms of size of the generated executables where the
bytecode is almost 8 times bigger without this option (since the \texttt{x}
value in C is a huge string that is statically allocated). We can even notice
that using packs returns the same size of code than without the option.
%% Finally, we compare the usage of \texttt{-pack} in front of \texttt{-no-alias-deps}

Finally, it can be interesting to show what are the dependencies of
\texttt{main.cmo}, to witness the \emph{weak dependencies propagation}. First of
all, here is the result of \texttt{ocamlobjinfo} on the normal behavior:

\begin{verbatim}
$ ocamlobjinfo main.cmo
File main.cmo
Unit name: Main
Interfaces imported:
        32426e00050b7af3f6584864744bd699      Ns
        487292a5ea53b458c1c5ec61282205df      Ns_c
        727f5a710d0c9f793431dc9ad08ec6c0      Printf
        e11a54484508793b436770ce5eab6405      Buffer
        ac02da8b7fc57b7e8f2908c2fe84cb62      Ns_a
        1c68752c7f711d4607125db93919a625      Ns_b
        694c578e10dc06471184517139073079      Pervasives
        179e236b77fab5842aaea6e1f5cf7292      Main
Uses unsafe features: no
Force link: no
\end{verbatim}

And with \texttt{-no-alias-deps}:

\begin{verbatim}
ocamlobjinfo ../main.cmo
File ../main.cmo
Unit name: Main
Interfaces imported:
        abe499d3c0a68d24e12116f354315fd8      Ns_a
        b535a55b20ef3a16e4fe514e82c82238      Ns_b
        32426e00050b7af3f6584864744bd699      Ns
        694c578e10dc06471184517139073079      Pervasives
        179e236b77fab5842aaea6e1f5cf7292      Main
Uses unsafe features: no
Force link: no
\end{verbatim}

We can notice that \texttt{Ns\_c} does not appear as a dependency in the second
case, which explains why it is not linked. It proves how the link is done
according to the next version of OCaml.

This trick can do a minimal job and does not change too much the actual code
base for users that used modules to simulate namespaces (it was actually the
goal of this implementation). However, those bits of namespaces are only on the
build system's side. It lacks extensivity, and functorization can be painful
since every compilation unit has to be encapsulated in a functor. Moreover, it
needs a strong build system to compute the dependencies, and a correct Makefile
can be hard to write according to this namespace strategy. Another point it
doesn't solve is the ability to link two compilation units with the same name
(and try to solve this point by using the new \emph{-o} behavior to add a prefix
at compile time).

In terms of dependencies, using the canonical name (not prefixed) and the
\texttt{-open} to build the dependencies correctly is not that strong. Indeed,
if one uses directly the fully qualified name of the module (for example
\texttt{Ns.A}), ocamldep will not be able to discover the dependency on
\texttt{a.ml}. When using \lstinline{open Ns}, there won't be any problem
however, but using fully qualified modules breaks the trick. 

In another hand, this new alias and weak dependencies semantics is rather
elegant and really helpfull, and can decrease a lot the size of the code.

This solution works thanks to the module aliases (which are no longer only
references), and in fact could be used, but it is complex enough to discourage
beginners to create their own. As a result, since it is rather a trick than a
real solution, we propose our own design that we aim to be clearer, simpler to
use and more expressive.
