\documentclass[11pt,a4paper]{article}

\usepackage{verbatim}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{listings}
\usepackage[utf8]{inputenc}

\lstnewenvironment{OCaml}
                  {\lstset{
                      language=[Objective]Caml,
                      breaklines=true,
                      %% commentstyle=\color{purple},
                      %% stringstyle=\color{red},
                      %% identifierstyle=\ttfamily,
                      %% keywordstyle=\color{blue},
                      basicstyle=\footnotesize\tt,
                      otherkeywords={namespace, abstract}
                    }
                  }
                  {}

% Fourth revision

\title{Namespaces for OCaml - Proposal}

\begin{document}

\maketitle

This proposal is about integrating namespaces into the OCaml language, but
without changing the semantics of the language and cluttering it. It aims to be
rather independent from the core language and viewed as a meaning for the user to
describe its compilation environment, and helping the compiler without the need
of external tools for simple compilation.

It tightly binds the build system, the file system and the language together,
helping the compiler to reason about installed libraries.
It focuses on the following points:
\begin{itemize}
\item Semantics in the language
\item Compilation according to namespaces
\item Installation and linking of libraries
\end{itemize}

What we want to solve in particular is integrating the \emph{big-functor} patch
at the namespace level, allowing to have paramteric libraries. At the end, we
present some use case of namespaces.

One particular goal we want to achieve is making a clear distinction between the
language's semantics and the code generation, in other word making the language
more expressive. %% , especially in cases like -pack and -pack-functor, which are
%% defined in the build system but are part of the semantics of the program.

An option had been added then, thanks to ``module aliases'', to avoid linking
necessity when an alias in unused, which simulates a namespace
mechanism. However, it remains an option of the compiler, that triggers a
warning and allows some some vicious links. It will be explained in the next
section.

Our namespaces proposal aims to solve this issue by designing real namespaces,
with a particular semantics, without a hard to understand compilation scheme
introduced by the last version of the compiler.


\input{soa}

\section{Semantics in the language}

Namespaces are integrated into the language, they are a meaning to represent
\emph{hierarchies} of modules and namespaces, helping the user to use multiple
modules from different libraries, and possibly with the same name, without using
long-prefixed names or aliases. For the library provider, it allows the
possibility to use simpler names.

Namespaces are not directly used inside the language, but in a prelude of each
module to describe the ``compilation environment''. Only \emph{toplevel modules}
(as compilation unit) can belong to namespaces, not submodules. A namespace is
simply declared: 

%% \begin{figure}[H]
\begin{verbatim}
prelude ::=
    | "in" "namespace" mod_longident imports 
    | imports

implementation ::=
    | prelude structure EOF
    | structure EOF

interface ::=
    | prelude signature EOF
    | signature EOF
\end{verbatim}
%% \caption{Namespace declaration}
%% \end{figure}

This construction allows to declare modules into subnamespaces. The following
example is valid:

\begin{OCaml}
in namespace Inria.Std
\end{OCaml}

%% Namespaces can take arguments, in other words they can abstract some of their
%% implementation and became modular. The argument of the ``functor'' has to be a
%% \texttt{.mli} available in the namespace (in this syntax the module signature is
%% not explicit, it is not clear for now if it shoud be since the mli/cmi is the
%% signature). For now, it is not clear if this argument must be explicit for each
%% modules in the namespace, or only those that uses it. If it has to be explicited
%% (even if unused) in each, the result would be that the interface used to type
%% this argument would also have a ``virtual'' access to it, resulting in a false
%% recursive module.

%% In this proposal, the functorized namespaces are part of the language, not only
%% defined at the build system level (like functor-pack): it is an essential part
%% of our proposal and useful to understand how the namespaces are organized and
%% used.

\medskip

There is actually two possible propositions, with two semantics. The first
imports modules from namespaces directly in the environment. The other imports
the complete path of the module, in other word each modules qualified by their
namespace. The syntax is almost the same, the only difference is
\texttt{ns\_conf} which differs according to our two proposals. 


%% \begin{figure}[H]
\begin{verbatim}
module_name = uident

imports ::=
    | 
    | import imports 

import ::=
    | ("with|"and)" ns_conf                           module importation    

// for the first proposal
ns_conf ::=
    | "(" modules_constraints ")" "of" mod_long_ident 
                                                      modules constraints

// for the second proposal
ns_conf ::=
    | mod_long_ident "." "(" module_constraints ")"

modules_constraints ::=
    | module_constraint
    | module_constraint ";" module_constraints

modules_constraint ::=
    | "_"                                             "wildcard": every other modules
    | module_name "as" module_name                    aliased module
    | module_name "as" "_"                            shadowed module
    | module_name                                     a module
\end{verbatim}
%% \caption{Namespace use}
%% \end{figure}

\paragraph{First proposal}

The syntax is rather simple, and can be simply described. The imports allows the
user to declare which modules to use from this namespace. 

Then an import clause
\begin{OCaml}
with (List) of Inria.Std
\end{OCaml}
is elaborated into
\begin{OCaml}
module List = ``module List from namespace Inria.Std''
\end{OCaml}

\paragraph{Second proposal}

On the contrary, modules are not directly imported in the environment. The
complete path is accessible, and the namespaces can be used as modules (with
some restrictions). In this idea, namespaces are kind of modules, and have a
signature. In fact, this implementation does an elaboration of the import
clauses into multiple modules and sub modules.

In other word, if we suppose
\begin{OCaml}
with Ocsigen.(Lwt, Server as S)
\end{OCaml}
it would be elaborated into
\begin{OCaml}
module Ocsigen = struct
  module Lwt = ``lwt.cmo of namespace Ocsigen''
  module S = ``server.cmo of namespace Ocsigen''
end
\end{OCaml}

As it can be noticed, it cannot be entirely done using the actual syntax, since
it needs to be able to refer to some modules from namespaces. It cannot be done
with a preprocessor and a syntax extension since the compiler has to reason
about modules inside namespaces. On another hand, the entire prelude has to be
computed before elaboration: since namespaces can hav subnamespaces, the entire
path must be resolved.

For example, let suppose the following prelude:
\begin{OCaml}
with Inria.Unsafe.(Obj)
and Inria.Std.(Hashtbl)
\end{OCaml}
If we elaborated line by line:
\begin{OCaml}
module Inria = struct
  module Unsafe = struct
    module Obj = ...
  end
end

module Inria = struct
  module Std = struct
    module Hashtbl = ...
  end
end

\end{OCaml}
However, only the second module \texttt{Inria} would be available. A correct
elaboration would then need to first discover the environment that will be
needed, resulting in:
\begin{OCaml}
module Inria = struct
  module Unsafe = struct
    module Obj = ...
  end
  module Std = struct
    module Hashtbl = ...
  end
end
\end{OCaml}


\medskip

In both proposals, the constraints are the same. The wildcard allows to import
in the environment every modules of the namespace that are not declared in the
current constraints. Shadowing doesn't add the module (it is only useful when
using the wildcard), and aliasing allows to have module from multiple namespace
with the same original name.

Importing a namespace does not import the subnamespaces. Being in a namespace
allows to directly import every modules from it. Modules without namespaces are
accepted and virtually doesn't belong to one. Actually, there is a \emph{global}
namespace (like C\# of F\#) for this specific issues.


In both propositions, namespaces and modules share the same ``namespace'' (i.e.,
a namespace cannot have the same name as a module, and vice-versa).

The possibilities inside the language are simple, but there are some possible
extensions that will be discussed later.

\section{Compilation}

\paragraph{Dependencies}

The dependency computation would not change too much and would be helped thanks
to the header. This would allow to retrieve the namespace of each module (except
when using the wildcard import, which is trickier without having knowledge of
the existing namespaces available in the program).

This wildcard issue is only relevant in the case we want namespaces to be given
along with modules' name with the option \texttt{-modules}. It can be solved by
simply changing the behavior of the existing algorithm. For now, asking for raw
dependencies simply prints the modules that are used, without even looking for
the corresponding \texttt{.ml(i)} files in the loadpath. What is proposed is
using the normal behavior and check if a file exists when a namespace cannot be
derived, checking if files that corresponds uses one namespace from the imports
(that only use wildcards). It can refine the dependencies of the compiled
program, and let the build system deal with modules whose namespaces aren't
found (because they belong to external libraries that are linked with the
program). This algorithm would be used however in the original ocamldep's
behavior, when looking for the .ml in the loadpath: when namespace cannot be
resolved, each file in the loadpath with the same name as the module is checked
to possibly retrieve one that belongs to a namespace imported with wildcard. It
can be an option of ocamldep, and it will simply read the first three tokens of
the files that could match to retreive the namespace.


\paragraph{Compilation unit}

Since namespaces allows the possibility of modules with the same name to be
linked together, internal name must be extended to be a long name, which is simply
using the namespace as a prefix. It is done in the .cmi files, allowing ocamlc
and ocamlopt both be able to use this information. The prefix can be the
namespace and maybe some other information, like a version information: it would
allow to link two versions of the same library in the same program. A use case
of such a feature could be for debugging features that have been rewritten
between two versions, or simply benchmarking a new version against the old one.


\paragraph{Linking} We will suppose for now that linking is simply giving a name
of a library (or a path), without bothering for looking how are organized those
libraries on the filesystem. It will be explained in the next section.

An important property of namespaces is they are \emph{extensible}, meaning that
anyone can add a module to an existing namespace. In other words, linking two
libraries that exports the same namespaces will \emph{merge} them into
one. Actually, it is the current behavior during link with modules: if two
modules have the same name in the loadpath, only the first one found (according
to the order of -I given to the compiler) is used (see formula (\ref{merge}). In
our merge semantics, we follow the same rules: when two namespaces have the same
name, the result is a namespace that contains the modules from both, and in case
of conflicting modules only the first one found are kept.

A formal representation is the following: suppose the loadpath $LP$, which
contains paths $P_i$. Each path $P_i$ is a directory that contains compilation
units $C_j$ and directories $D_k$. Then, the compilation units are:

\begin{multline}
\forall D_1, D_2 \in P_1, P_2, D_1 = D_2
\rightarrow P_1 \oplus' P_2 = P_1 \oplus P_2 + D_1 \oplus D_2
\label{ns-merge} 
\end{multline}

It is a recursive definition, meaning that subfolders are also taking in
consideration. As a result $\oplus$ is replaced by $\oplus'$ when computing the
available compilation units.

For example, we can consider the two following libraries:

\begin{verbatim}
(* "global" is the root namespace *)

(* For stdlib *)
global ---- Std ---- List
                  |- Hashtbl
                  |- ...

(* For ocamlpro *)
global ---- Std ---- List
         |- ...   |- Utils
                  |- ...
\end{verbatim}
and we suppose the library \emph{ocamlpro} is linked using \texttt{-I +ocamlpro}.

\texttt{stdlib} is always linked last, meaning that any libraries using the
\texttt{``global''.Std} namespace would conflict with it. The result is that the
modules in \texttt{Ocamlpro/Std} would subsume those existing with the same name
from the standard library. If one use \texttt{List} in its program, it would be
the one from OCamlPro. But modules that do not not exists in
\texttt{Ocamlpro/Std} are still accessible.


\paragraph{Parametric namespaces}

\textbf{Work-in-progress}

Namespaces can be parametric and use multiple implementations over one
interface. A module can be abstracted and considered as a \emph{parameter} in
the namespace. 

The actual functor pack patch adds two fields to cmis/cmos/cmxs:
\lstinline{functor_part} and \lstinline{functor_args}. They can certainly be
reused for modules that belong in such a namespace. It will be completely
explicit in the build system. For example, let assume a namespace \texttt{Ns}
which is parametric over an interface \texttt{Arg}. Its modules are compiled
with the option 

\begin{verbatim}
ocamlc -functor arg.cmi a.ml
\end{verbatim}

We can then instantiate them by applying them an argument, which would result on
a new namespace that corresponds of the applied version on this specific
argument. Instantiating the modules would lead to 

\begin{verbatim}
ocamlc -apply x.cmo -ns NsX a.cmo 
(* the namespace has to be given as an option since there does not exists a
 source file for the original *)
\end{verbatim}

As a result, the instantiation is done once and for all. This would introduce a
concept of ``functor-units''.

\section{Installation and file system relationship}

One of the advantage of namespaces is their ability to provide a nice way to
define how libraries are installed and how the compiler should look for the
modules. As a result, we can leverage the need for external tools to compile
using external libraries, especially for simple programs.

\paragraph{Compiled modules and installation}

Namespaces and file system organization are highly related: a namespace is a
directory, at least after compilation (it has been hinted in (\ref{ns-merge})
actually). For example, if the module belongs to the namespace
\texttt{Inria.Std}, its compilation result will be placed in the directory
\texttt{inria/std}. As a result, the compiler will be able to look for modules
in namespaces and subnamespaces simply by scanning recursively the folders in
its loadpath. Sources should belong to the same directory, and it could help
ocamldep to look for dependencies without having to check the ``in namespace''
declaration. However, it can be avoided, and the compiler will create the
correct directories thanks to the ``in namespace'' information.

When linking, those folders are looked for from the loadpath: there is not a
global folder where modules from different libraries are placed. It would be
quite hard to link a library since the compiler would have to look for each
modules that belongs to that library. Moreover, installing a library that
extends a namespace and redefines some of its existing modules would be clearly
dangerous, and could lead to overwriting files.

To allow those namespaces to be used without external tool, we propose to add a
canonical path where libraries should be installed, which would be symbolized by
``+'' before the folder name with \texttt{-I}. This path can be set by an
environment variable of the system (\texttt{OCAML\_LD\_PATH} for
example). Linking a library is simply giving the folder where it is installed to
\texttt{-I}. Modules that doesn't have a namespace can be found at the root of
the loadpath. Another possibility is to use an option \texttt{-lib} to refer to
libraries stored in the canonical install path: it would not change the \texttt{-I}
behavior.

Having such a standard library path for user libraries is relevant, thanks to
the use of OPAM: the user's libraries are installed in the
\texttt{~/.opam/<version>/lib/} directory, and it can be used as a standard
installation path. 

\paragraph{Alternative to hierarchical filesystem}

Whereas file system is a good way to organize namespaces, some could want a way
to flatten this hierarchy to avoid scanning (it can be too slow on some
operating system). The idea is to provide a file (\texttt{.ns}) that simply
describes where are the files of the library, and in which namespace they
belong. It has the following simple syntax:

\begin{verbatim}
lines ::=
    | EOF
    | line "\n" lines EOF

line ::= filepath ":" mod_longident
\end{verbatim}

The compiler can create this file during compilation, or we can imagine a simple
program (\emph{ocamlns}) which would read the namespace information of each file
to create this \texttt{.ns}. It would be available at the root of each installed
libraries (in each -I added folder) and read by the compiler.


\section{Others concerns and future extensions}

\paragraph{-pack with namespace}

The problem namespaces resolves is the -pack issue, however some would still
want to use both in a program. In that case, the packing result maybe could have
a namespace. The behavior is then:
\begin{itemize}
\item if every modules to be packed are in the same namespace, then the
  ``package'' is in the same.
\item if namespaces are different, -pack fails.
\end{itemize}

In this constraints, the -pack is backward compatible since modules without
namespaces doesn't belong to a namespace at all (at least virtually).

\paragraph{-functor-pack with namespaces}

The rules are the same as with -pack: the \emph{big functor} belongs to the same
namespace as its functors packed.

\paragraph{Automatically opened modules}

Namespaces can be an elegant way to declare libraries. We can suppose a library
wants one of its modules is always opened when using it, ``à-la''
Pervasives. A possibility would be to open automatically modules whose name is
Pervasives when using a namespace. It binds the name to a specific semantics,
but is relevant since some languages binds the \emph{main} name as the entry
point of a program.

%% It
%% would be syntactically easy to add such a feature, by adding the keyword
%% ``opened'' at the beginning of the namespace declaration, but it needs more
%% thoughts at compilation and linking. There are some way to do it, especially by
%% adding a directory \texttt{``\_opened''} in the installed library for each
%% namespaces with such modules, that the compiler would recognize as the
%% automatically opened ones. As a result, when importing a library (even one
%% module), the opened ones are automatically imported. Aliasing or shadowing
%% them prevent this behavior.

%% This proposition is part of the 4.02 version of OCaml: a \texttt{-open} option
%% had been added, what we propose is specifying modules that should be opened
%% directly in the language, making this option automatic when using the namespace.

\section{Use-case}

We present some use cases of namespaces in the language, we use the first
proposal in it, but the semantics is the same.


\subsection{Extending libraries}

Namespaces are extensible, in other words, one can add any module in it. It can
be useful to extend the standard library, or replacing some modules with an
implementation more efficient. We suppose the standard OCaml library belongs to
the namespace Inria.Std (we suppose its modules are automatically
imported).

\begin{OCaml}
(** hashset.ml *)
in namespace Inria.Std
...
\end{OCaml}

\begin{OCaml}
(** string.ml, a replacement for the original String module *)
in namespace Inria.Std

(* we need to first alias the original String *)
  with (String -> S) of Inria.Std

include S

(* some new functions and rebindings of String *)
...
\end{OCaml}

Supposing this extended library is installed into \texttt{+extendedlib}, the
compilation of a program M using it is simply:
\begin{verbatim}
ocaml(c|opt) -o prog -I +extendedlib m.ml
\end{verbatim}

Of course, the String module we've defined is not used by the modules from the
``original'' namespace but only by our extended version.

\subsection{Parameterized library}

Suppose we're writing a library that uses a specific asynchronous monad, like
Lwt, but without without specifying implementation, leaving the choice up to the
user. Suppose this library is an implementation for the HTTP protocol. The modules
from this library resides in the namespace Mylib.Http. Protocol is the main module.

\begin{OCaml}
(** async_monad.mli *)
in namespace Mylib.Http

type t

val (>>=) : 'a t -> ('a -> 'b t) -> 'b t

val return : 'a -> 'a t
val bind : 'a t -> ('a -> 'b t) -> 'b t (* == (>>=) *)
val poll : 'a t -> 'a option
...
\end{OCaml}

\medskip

\begin{OCaml}
(** protocol.ml *)

in namespace MyLib.Http

open Async_monad
...
\end{OCaml}

The compilation of our module is:

\begin{verbatim}
ocamlc -c -functor Async_monad protocol.ml
\end{verbatim}

\medskip

Now suppose your writing a server, using this HTTP library (we suppose it
belongs to a namespace Myserver). First of all, we have to instantiate our
namespace over an implementation of our monad:

\begin{verbatim}
ocamlc -I +ocsigen-lib -apply Ocsigen.Lwt -ns Mylib.Http_Lwt protocol.cmo
... # We do the same for the other modules in this namespace 
\end{verbatim}

We then create a new namespace Mylib.Http\_Lwt that corresponds to the
instantiation of Mylib.Http over Ocsigen.Lwt.

\begin{OCaml}
(** main_lwt.ml *)
in namespace Myserver
  with (Lwt) of Ocsigen
  and (Protocol) of MyLib.Http_Lwt
...
\end{OCaml}

\subsection{Multiple instantiation}

Suppose a library using a SAT-solver to prove the correctness of some values it
is using. There exists multiple SATisfiability solving algorithms (mainly DPLL
and CDCL, with multiple variants), and one case of functors at the namespace
level would be to instantiate multiple versions of a library and benchmark the
different implementations.

Suppose our library, particularly composed by a \emph{hole} Sat and a module
Solver. The library defines its namespace MySolver.

\begin{OCaml}
(** sat.mli *)
in namespace MySolver

type bnf

val solve: bnf -> bool
\end{OCaml}

\medskip 

\begin{OCaml}
(** solver.ml *)
in namespace MySolver

let is_sat f =
... 
(* some preliminary computations, like turning the formula into its bnf *)
  let sat = Sat.solve formula in 
...
\end{OCaml}

\begin{verbatim}
ocamlc -c sat.mli
ocamlc -c -functor Sat solver.ml
\end{verbatim}

\medskip

Finally, our Solver can be used by the following benchmarking modules:

\begin{verbatim}
ocamlc -apply Dpll -ns MySolver_Dpll solver.cmo
... # every other modules to instantiate

ocamlc -apply Cdcl -ns MySolver_Cdcl solver.cmo
... # idem 
\end{verbatim}

\begin{OCaml}
(** bench.ml *)
with (Parser, Solver as Solve_Dpll) of MySolver_Dpll
and (Solver as Solve_Cdcl) of MySolver_Cdcl

...
let compute_and_print_time l = ...
...

let () =
  let formulas = 
    Parser.open_read_and_parse Sys.argv.[1] in
  let eval f =
    let t1 = Sys.time () in
    ignore (Solve_Dpll.is_sat f);
    let t2 = Sys.time () in
    ignore (Solve_Cdcl.is_sat f);
    let t3 = Sys.time () in
    (t2 - t1, t3 - t2)
  in
  let times = List.map eval formulas in
  compute_and_print_time times
\end{OCaml}

\subsection{Importing modules with the same name}

One problem that can be easily solved is the ability to use two compilation
units that share the same name, thanks to the importing constraints and even the
full qualified path of the second proposal. Both proposal can use constraints,
but second can be even more powerful.

For example, suppose the Batteries modules are not prefixed with
\texttt{``Bat\_''}, it would not be possible to use List from the Stdlib against
the one from Batteries.

\begin{OCaml}
with (List as BList) of Batteries
and (List as OList) of Inria.Std
\end{OCaml}

With the second proposal, aliasing is possible but not mandatory since it makes
qualification explicit.

\begin{OCaml}
with Batteries.(List)
and Inria.Std.(List)
\end{OCaml}

%% \bibliographystyle{abbrv}
%% \bibliography{biblio} 

\end{document}
