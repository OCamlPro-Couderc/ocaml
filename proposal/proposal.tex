\documentclass[11pt,a4paper]{article}

\usepackage{verbatim}
\usepackage[english]{babel}
%% \usepackage{float}
\usepackage{listings}
\usepackage[utf8]{inputenc}

\lstnewenvironment{OCaml}
                  {\lstset{
                      language=[Objective]Caml,
                      breaklines=true,
                      %% commentstyle=\color{purple},
                      %% stringstyle=\color{red},
                      %% identifierstyle=\ttfamily,
                      %% keywordstyle=\color{blue},
                      %% basicstyle=\footnotesize,
                      otherkeywords={namespace, abstract}
                    }
                  }
                  {}

% Fourth revision

\title{Namespaces for OCaml - Proposal}

\begin{document}

\maketitle

This proposal is about a mecanism to reason about namespace, integrated into the
OCaml language, but without changing the semantics of the language and
cluttering it. It aims to be rather independent from the language and viewed as
a meaning for the user to describe its compilation environment, and helping the
compiler without the need of external tools for simple manipulation.

It tightly binds the build system, the file system and the language together,
helping the compiler to reason about installed libraries.
It focuses on the following points:
\begin{itemize}
\item Semantics in the language
\item Compilation according to namespaces
\item Installation and linking of libraries
\end{itemize}

At the end, we present some use case of namespaces.

\section{Semantics in the language}

Namespaces are integrated into the language, they are a meaning to represent
\emph{hierarchies} of modules and namespaces, helping the user to use multiple
modules without using long-prefixed names or aliases. For the library provider,
it allows the possibility to use simple names.

Namespaces are not directly used inside the language, but in a prelude of each
module to decribe the ``compilation environment''. Only \emph{toplevel modules}
(as compilation unit) can belong to namespaces, not submodules. A namespace is
simply declared: 

%% \begin{figure}[H]
\begin{verbatim}
implementation ::=
    | "in" "namespace" mod_longident headers structure EOF
    | structure EOF

interface ::=
    | "in" "namespace" mod_longident signature EOF
    | "abstract" "in" "namespace" mod_longident signature EOF
    | signature EOF
\end{verbatim}
%% \caption{Namespace declaration}
%% \end{figure}

This construction allows to declare modules into subnamespaces. The following
example is valid:

\begin{OCaml}
in namespace Inria.Std
\end{OCaml}

The \texttt{abstract} keyword for interfaces defines a \emph{hole} in the
namespace, in other word a module whose implementation will be resolved at link
time. We consider a module cannot be abstract and having an implementation in
the namespace, it would result on an error. However, this possibility might be
considered in the future, allowing default implementation for holes.

\medskip

As in other languages, namespaces are imported, meaning allowing to use the modules
imported. Namespaces cannot be used to qualify modules. The syntax, which can
change and is only a representation of the possibilities, is the following:

%% \begin{figure}[H]
\begin{verbatim}
module_name = uident

imports ::=
    |
    | import imports 

import ::=
    | "import" ns_conf                                module importation    

ns_conf ::=
    | mod_long_ident "." "(" modules_constraints ")"  modules constraints
    | mod_long_ident instance_args "." "(" modules_constraints ")"
                                                      namespaces instantiation 

instance_args ::=
    | "(" module_name "=" module_name ")"
    | "(" module_name "=" module_name ")" instance_args

modules_constraints ::=
    | module_constraint
    | module_constraint ";" module_constraints

modules_constraint ::=
    | "_"                                             every other modules
    | module_name "->" module_name                    aliased module
    | module_name "->" "_"                            shadowed module
    | module_name                                     a module
\end{verbatim}
%% \caption{Namespace use}
%% \end{figure}

The syntax is rather simple, and can be simply described. The import allows the
user to declare which modules to use from this namespace, but also which not to
use. The wildcard allows to import in the environment every modules of the
namespaces that are not declared in the current constraints. Shadowing doesn't
import the module (it is only useful when using the wildcard), and aliasing
allows to have module from multiple namespace with the same original name.

Importing a namespace does not import the subnamespaces. Being in a namespace
allows to directly import every modules from it. Modules without namespaces are
accepted and virtually doesn't belong to one. Actually, there is a \emph{global}
namespace (like C\# of F\#) where they belong to.

A namespace can be imported and instantiated over some implementation. It allows
parametric libraries, and will be explained in the compilation section. It is
mandatory to explicitely affect the abstracted module, since there can't be any
possibility to give the order of those modules, especially because namespaces
are extensible.

The possibilities inside the language are simple, but there are some possible
extensions that will be discussed later.

\section{Compilation}

\paragraph{Dependencies}

The dependency computation would not change too much and would be helped thanks
to the import clause. This would allow to retrieve the namespace of each module
(except when using the wildcard import, which is trickier without having
knowledge of the existing namespaces available in the program).

This wildcard issue is only relevant in the case we want namespaces to be given
along with modules' name with the option \texttt{-modules}. It can be solved by
simply changing the behavior of the existing algorithm. For now, asking for raw
dependencies simply prints the modules that are used, without even looking for
the corresponding .ml(i) file in the loadpath. What is proposed is using the
normal behavior and check if a file exists when a namespace cannot be derived,
checking if files that corresponds uses one namespace from the imports (that
only use wildcards). It can refine the dependencies of the compiled program, and
let the build system deal with modules whose namespaces aren't found (because
they belong to external libraries that are linked with the program). This
algorithm would be used however in the original ocamldep's behavior, when
looking for the .ml in the loadpath: when namespace cannot be resolved, each file
in the loadpath with the same name as the module is checked to possibly retrieve
one that belong to a namespace imported with wildcard.


\paragraph{Compilation unit}

Since namespaces allows the possibility of modules with the same name to be
linked together, internal name must be extended to be a long name, which is simply
using the namespace as a prefix. It is done in the .cmi files, allowing ocamlc
and ocamlopt both be able to use this information. The prefix can be the
namespace and maybe some other information, like a version information: it would
allow to link two versions of the same library in the same program. A use case
of such a feature could be for debugging features that have been rewritten
between two versions, or simply benchmarking a new version against the old one.


\paragraph{Linking} We will suppose for now that linking is simply giving a name
of a library (or a path), without bothering for looking how are organized those
libraries on the filesystem. It will be explained in the next section.

An important property of namespaces is they are \emph{extensible}, meaning that
anyone can add a module to an existing namespace. In other words, linking two
libraries that exports the same namespaces will \emph{merge} them into
one. Actually, it is the current behavior during link with modules: if two
modules have the same name in the loadpath, only the first one found (according
to the order of -I given to the compiler) is used. In our merge semantics, we
follow the same rules: when two namespaces have the same name, the result is a
namespace that contains the modules from both, and in case of conflicting
modules only the first one found are kept.

For example, we can consider the two following libraries:

\begin{verbatim}
(* "global" is the root namespace *)

(* For stdlib *)
global ---- Std ---- List
                  |- Hashtbl
                  |- ...

(* For ocamlpro *)
global ---- Std ---- List
         |- ...   |- Utils
                  |- ...
\end{verbatim}
and we suppose the library \emph{ocamlpro} is linked using \texttt{-I +ocamlpro}.

\texttt{stdlib} is always linked, meaning that any libraries using the
\texttt{``global''.Std} namespace would conflict with it. The result is that the
modules in \texttt{Ocamlpro/Std} would subsume those existing with the same name
from the standard library. If one use \texttt{List} in its program, it would
be the one from OCamlPro. But modules that don't belong to \texttt{Ocamlpro/Std}
are still accessible.


\paragraph{Parametric namespaces}

Namespaces can be parametric and use multiple implementations over one
interface. A module can be abstracted and considered as a \emph{hole} in the
namespace. Later in the program, this hole can be filled with an implementation
that type checks against this interface. This case is actually solved during the
linking phase, by feeding the compiler with the correct .cmo. As a result, only
compilation units can be used, but this shouldn't be a problem since only
toplevel modules can be found during the importing phase.

A parametric namespace doesn't have to be instantiated each time it is used, and
simply use the abstract module. However, it has to be to produce an executable
(for a cma, it can be left abstracted even if it is not recommended for the
comprehension). When an affectation is done, the compiler looks if there exists
an abstracted module with the name given, and gives the corresponding module to
each others that needs it.

The representation of this hole, and how the link would work is rather unclear
for now. It could be some field in the compilation units that refers to it but
considered as an alias for a name that doesn't exists yet.

\section{Installation and file system relationship}

One of the advantage of namespaces is their ability to provide a nice way to
define how libraries are installed and how the compiler should look for the
modules. A nice property is it allows to get ride of external tools to look for
specific modules in external libraries.

\paragraph{Compiled modules and installation}

Namespaces and filesystem organization are highly related: a namespace is a
directory, at least after compilation. For example, if the module belongs to the
namespace \texttt{Inria.Std}, its compilation result will be placed in the
directory \texttt{inria/std}. As a result, the compiler will be able to look for
modules in namespaces and subnamespaces simply by scanning recursively the
folders in its loadpath. Sources should belong to the same directory, and it
could help ocamldep to look for dependencies without having to check the ``in
namespace'' declaration. However, it can be avoided, and the compiler will
create the correct directories thanks to the ``in namespace'' information.

When linking, those folders are looked for from the loadpath: there is not a
global folder where modules from different libraries are placed. It would be
quite hard to link a library since the compiler would have to look for each
modules that belongs to that library. Moreover, installing a library that
extends a namespace and redefines some of its existing modules would be clearly
dangerous, and could lead to overwriting files.

To allow those namespaces to be used without external tool, we propose to add a
canonical path where libraries should be installed, which would be symbolized by
``+'' before the folder name with \texttt{-I}. This path can be set by an
environment variable of the system (\texttt{OCAML\_LD\_PATH} for
example). Linking a library is simply giving the folder where it is installed to
\texttt{-I}. Modules that doesn't have a namespace can be found at the root of
the loadpath.

\paragraph{Alternative to hierarchical filesystem}

Whereas filesystem is a good way to organize namespaces, some could want a way
to flatten this hierarchy to avoid scanning (it can be too slow on some
operating system). The idea is to provide a file (\texttt{.ns}) that simply
describes where are the files of the library, and in which namespace they
belong. It have the following simple syntax:

\begin{verbatim}
lines ::=
    | EOF
    | line "\n" lines EOF

line ::= filepath ":" mod_longident
\end{verbatim}

The compiler can create this file during compilation, or we can imagine a simple
program (\emph{ocamlns}) which would read the namespace information of each file
to create this \texttt{.ns}. It would be available at the root of each installed
libraries (in each -I added folder) and read by the compiler.


\section{Others concerns and future extensions}

\paragraph{-pack with namespace}

The problem namespaces resolves is the -pack issue, however some would still
want to use both in a program. In that case, the packing result maybe could have
a namespace. The behavior is then:
\begin{itemize}
\item if every modules to be packed are in the same namespace, then the
  ``package'' is in the same.
\item if namespaces are different, -pack fails.
\end{itemize}

In this constraints, the -pack is backward compatible since modules without
namespaces doesn't belong to a namespace at all (at least virtually).

\paragraph{-functor-pack with namespaces}

The rules are the same as with -pack: the \emph{big functor} belongs to the same
namespace as its functors packed.

\paragraph{Automatically opened modules}

Namespaces can be an elegant way to declare libraries. We can suppose that a
library wants that a module is always opened when using it, ``à-la''
Pervasives. It would be syntactically easy to add such a feature, by adding the
keyword ``opened'' at the beginning of the namespace declaration, but it needs
more thoughts at compilation and linking. There are some way to do it,
especially by adding a directory \texttt{``\_opened''} in the installed library
for each namespaces with such modules, that the compiler would recognize as the
automatically opened ones. As a result, when importing a library (even one
module), the opened modules are automatically imported. Aliasing or shadowing
them prevent this behavior.

\section{Use-case}

\subsection{Extending libraries}

Namespaces are extensible, in other words, one can add any module in it. It can
be useful to extend the standard library, or replacing some modules with an
implementation more efficient. We suppose the standard OCaml library belongs to
the namespace Inria.Std (we suppose its modules are automatically
imported).

\begin{OCaml}
(** hashset.ml *)
in namespace Inria.Std
...
\end{OCaml}

\begin{OCaml}
(** string.ml, a replacement for the original String module *)
in namespace Inria.Std

(* we need to first alias the original String *)
import Inria.Std.(String -> S)

include S

(* some new functions and replacements for String *)
\end{OCaml}

Supposing this extended library is installed into \texttt{+extendedlib}, the
compilation of a program M using it is simply:
\begin{verbatim}
ocaml(c|opt) -o prog -I +extendedlib m.ml
\end{verbatim}

Of course, the String module we've defined is not used by the modules from the
``original'' namespace but only by our extended version.

\subsection{Libraries using ``holes''}

Suppose we're writing a library that uses a specific asynchronous monad, like
Lwt, but without without specifying implementation, leaving the choice up to the
user. Suppose this library is an implementation for the HTTP protocol. The modules
from this library resides in the namespace Mylib.Http. Protocol is the main module.

\begin{OCaml}
(** async_monad.mli *)
abstract in namespace Mylib.Http

type t

val (>>=) : 'a t -> ('a -> 'b t) -> 'b t

val return : 'a -> 'a t
val bind : 'a t -> ('a -> 'b t) -> 'b t (* == (>>=) *)
val poll : 'a t -> 'a option
...
\end{OCaml}

\medskip

\begin{OCaml}
(** protocol.ml *)

in namespace MyLib.Http

open Async_monad
...
\end{OCaml}

\medskip

Now suppose your writing a server, using this HTTP library (we suppose it belongs
to a namespace Myserver):

\begin{OCaml}
(** main_lwt.ml *)
in namespace Myserver

import Ocsigen.(Lwt)
import MyLib.Http(Async_monad = Lwt).(Protocol)
...
\end{OCaml}

The program is then instantiated over Lwt, and there can be multiple servers for
each possible asynchronous monad that implements the same interface.

\subsection{Multiple instantiation}

Suppose a library using a SAT-solver to prove the correctness of some values it
is using. There exists multiple SATisfiability solving algorithms (mainly DPLL
and CDCL, with multiple variants), and one case of using ``holes'' would be to
instantiate multiple versions of a library and benchmark the different
implementations.

Suppose our library, particularly composed by a \emph{hole} Sat and a module
Solver. The library defines its namespace MySolver.

\begin{OCaml}
(** sat.mli *)
abstract in namespace MySolver

type bnf

val solve: bnf -> bool
\end{OCaml}

\medskip 

\begin{OCaml}
(** solver.ml *)
in namespace MySolver

let is_sat f =
... 
(* some preliminary computation, like turning the formula into its bnf *)
  let sat = Sat.solve formula in 
...
\end{OCaml}

\medskip

Finally, our Solver can be used by the following benchmarking module:

\begin{OCaml}
(** bench.ml *)
import MySolver(Sat = Dpll).(Parser, Solver -> Solve_Dpll)
import MySolver(Sat = Cdcl).(Solver -> Solve_Cdcl)

...
let compute_and_print_time l = ...
...

let () =
  let formulas = 
    Parser.open_read_and_parse Sys.argv.[1] in
  let eval f =
    let t1 = Sys.time () in
    ignore (Solve_Dpll.is_sat f);
    let t2 = Sys.time () in
    ignore (Solve_Cdcl.is_sat f);
    let t3 = Sys.time () in
    (t2 - t1, t3 - t2)
  in
  let times = List.map eval formulas in
  compute_and_print_time times
\end{OCaml}

\medskip

As a result, we can see namespaces with holes as functorized namespaces. Of
course, this example could be done simply by functorizing directly Solver, but
it can be rather nice to let the linker do the job, and it allows every modules
in the namespace to be abstract over this specific interface.

\bibliographystyle{abbrv}
\bibliography{biblio} 

\end{document}
