\documentclass[11pt,a4paper]{article}

\usepackage{verbatim}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{listings}
\usepackage[utf8]{inputenc}

\lstnewenvironment{OCaml}
                  {\lstset{
                      language=[Objective]Caml,
                      breaklines=true,
                      %% commentstyle=\color{purple},
                      %% stringstyle=\color{red},
                      %% identifierstyle=\ttfamily,
                      %% keywordstyle=\color{blue},
                      basicstyle=\footnotesize\tt,
                      otherkeywords={namespace, abstract}
                    }
                  }
                  {}

% Fourth revision

\title{Namespaces for OCaml - Proposal}

\begin{document}

\maketitle

This proposal is about integrating namespaces into the OCaml language, but
without changing the semantics of the language and cluttering it. It aims to be
rather independent from the core language and viewed as a meaning for the user to
describe its compilation environment, and helping the compiler without the need
of external tools for simple compilation.

It tightly binds the build system, the file system and the language together,
helping the compiler to reason about installed libraries.
It focuses on the following points:
\begin{itemize}
\item Semantics in the language
\item Compilation according to namespaces
\item Installation and linking of libraries
\end{itemize}

What we want to solve in particular is integrating the \emph{big-functor} patch
at the namespace level, allowing to have paramteric libraries. At the end, we
present some use case of namespaces.

One particular goal we want to achieve is making a clear distinction between the
language's semantics and the code generation, in other word making the language
more expressive. %% , especially in cases like -pack and -pack-functor, which are
%% defined in the build system but are part of the semantics of the program.

An option had been added then, thanks to ``module aliases'', to avoid linking
necessity when an alias in unused, which simulates a namespace
mechanism. However, it remains an option of the compiler, that triggers a
warning and allows some some vicious links. It will be explained in the next
section.

Our namespaces proposal aims to solve this issue by designing real namespaces,
with a particular semantics, without a hard to understand compilation scheme
introduced by the last version of the compiler.

\section{Namespaces in OCaml: state of the art}

\subsection{Linking formalism}

First of all, it can be interesting to formalize what is a correctly linked
program. This mechanism will be different starting from 4.02, then it is
interesting to understand how the changes will affect the linked programs.

We will suppose the typechecking is always correct. Lets assume a program is
simply an ordered set $Pr$ of compilation units $\{C_0$, .. $C_n\}$. We suppose
$deps(C)$ the set of compilation units on which is dependent C. Then, we express
the dependency order by $\prec$, whereas $A \prec B$ means $B$ has a dependency
on $A$. The dependency is a strict order relationship, and as a result it is
transitive and not reflexive. Then:

$$A \prec B \leftrightarrow A \in deps(B)$$

%% Another property is the dependencies propagation:

%% \begin{equation}
%%   A \prec B \rightarrow deps(A) \subseteq deps(B)
%%   \label{propagate}
%% \end{equation}

The load path $LP$ is the set of paths $\{P_0, .., P_m\}$ where are stored
compilation units that can be used at link time. Then, we suppose $compunit(P)$
the set of available compilation units in the path $P$. We define $\oplus$ as
the merge operation of two sets ($S_1$ and $S_2$):

$$S_1 \oplus S_2 = S_1 \cup (S_2 - S_1 \cap S_2) $$

Then, the set of available compilation units $Cs$ from the load path at the path
$P_k$ is: 

\begin{equation}
Cs(P_m) = Cs(m-1) \oplus compunit(P-m) \text{ and } Cs(P_0) = compunit(P_0)
\label{merge}
\end{equation}

Morally, it is a \emph{fold left application} of $\oplus$ over the load path. We
will use it as $compunits(LP)$.

Let $M_i$ the source file for $C_i$. We assume $deps(\_)$ is also available for
source files, and returns the necessary compilation units ($deps(M_i) =
deps(C_i)$). Then $compile(M_i)$ is a predicate indicating if the source file
can be compiled (and $C_i$ its result), and

\begin{equation}
compile(M_i) \rightarrow deps(M_i) \subseteq compunits(LP)
\label{compile}
\end{equation}

As a result, we can express a correctly linked program as:

\begin{multline}
Pr ::= \{ C_0, .., C_n ~|~ \forall i \in [1; n], ~deps(C_i) \subseteq \{ C_0, ..,
    C_{i-1} \} \land deps(C_0) = \emptyset \}\\
    \text{whereas} ~ LP = \{ P_0, .., P_m \}~and~\forall i \in [0; n], C_i \in compunits(LP)
\label{linkable}
\end{multline}


On a side note, we can use the following predicate $recompile(C)$, that
indicates if a file has to be recompiled in that case. Morally, if one must be
recompiled, then the recompilation is propagated over those that depends on it:

\begin{equation}
  \forall C \in deps(X), recompile(C) \rightarrow recompile(X)
\label{recompile}
\end{equation}

\subsection{Prior 4.02.0}

In the current stable version (4.01.0), there is no namespace solution. The only
possibility is aliasing modules into a big one, which is a kind of
\emph{wrapper} module. A typical ``namespace module'' is simply a \texttt{.ml}
that only contains multiple:

\begin{OCaml}
module List = Mystd_List
\end{OCaml}

It has multiple bad properties:
\begin{enumerate}
  \item It is a bottleneck for dependencies: when one of the aliased module is
    recompiled, the wrapper must be recompiled, and in fact every module that
    depends on it must be compiled again (because of (\ref{recompile})).
  \item When using it as a namespace, every module aliased in it has to be
    linked: this kind of module can lead to build huge executables. Even if one
    of the alias is not used, it must be linked with the program since the
    wrapper is dependent on it. It is expressed above by the constraint $
    \forall i \in [1; n], ~deps(C_i) \subseteq \{ C_0, .., C_{i-1} \}$ in
    (\ref{linkable}).
  \item It is not extensible: Some would want to extend ``a posteriori'' a
    namespace they are using to add new modules or redefine them. The usage of
    modules means it is restricted by their semantics.
\end{enumerate}

Another possible solution is \emph{packing} the modules to make them appear as
if they were part of a namespace. The idea is to take every compilation unit,
and copy them into a single one that acts as a wrapper. As a result, using a
namespace is simply linking this huge compilation unit. It is completely managed
by the build system, and as a consequence the dependencies can be hard to
compute since the wrapper does not have a source file.

The last solution is simply prefixing modules' name to be unique, without a
\emph{wrapper} to access them: only necessary modules are linked, however it can
be a little painful for the user to use those long names.

\subsection{Since 4.02.0}

The next version of OCaml changes a bit the link process, by adding an option
\texttt{-no-alias-deps} that changes its semantics by making a difference
between \emph{aliases} and dependencies. It introduces the concept of weak
dependecies. Formally, it adds a new predicate $weakdeps(C)$ for each
compilation units. If the compilation unit $C$ aliases another compilation unit
(\texttt{module X = Y}) and is compiled using \texttt{-no-alias-deps}, then

$$\texttt{module~X = Y} \rightarrow Y \notin deps(C) \land Y \in weakdeps(C)$$ 

If $X$ is used (as qualifier, opened or used as argument of a functor or as
first-class argument), $Y$ is no longer part of weak dependencies but becomes a
srong one, then $\forall C, weakdeps(C) \cap deps(C) = \emptyset$. Moreover,
$weakdeps(C)$ is transitive:

\begin{multline} \\
\forall X, Y, Z \text{ fresh module names}, \\ A \prec B \\
\land X \in weakdeps(A) \\ 
\land \text{``module Y = X''} \in A \\
\land \text{``module Z = Y''} \in B \\
\rightarrow X \in weakdeps(B)
\end{multline}

In other word, aliasing a weak dependency of another compilation unit makes it a
weak dependency in the current environment (until it is used). The correctly
linked program equation does not change in this configuration, which then
implies some important properties:
\begin{itemize}
\item An unused alias does not have to be \emph{linked} for the program to be correct;
\item An unused alias does not have to be \emph{present} to compile.
\item A side effect of this option is that there is no bottleneck when a
  recompilation is needed, since the alias is propagated until it is
  used. However, it needs a strong build system to discover such propagation.
%% \item Dependencies are no longer propagated. In other word, the rule
%%   (\ref{propagate}) no longer applies. It can be witnessed in the
%%   experimentation below.
\end{itemize}

Another option added is the \texttt{-open}: it takes a module name and opens it
directly (it adds the opening statement in the AST).

Finally, the \texttt{-o} has been modified: the compilation unit name is now the
same as the filename given to the option (actually, only the left part before
the first ``.'').

\subsection{Example and experimentation}

Using those features, it is possible to simulate some kind of ``namespaces'' in
OCaml. Here is a complete example of how it works.

We are going to make a namespace Ns, which will contain three modules A, B and
C. Then Ns is simply a module that contains only aliases (the code of this
example is available in the same repository as this proposal):

\begin{OCaml}
(* ns.ml *)

module A = Ns_a
module B = Ns_b
module C = Ns_c
\end{OCaml}

Then, we define our modules:

\begin{OCaml}
(* a.ml *)
let print_from_A () = print_endline ``Hello from A!''

(* b.ml *)
let print_from_B () = print_endline ``Hello from B!''

(* c.ml *)
let x = ``lorem ipsum ...'' (* ~15000 characters long *)

let print_from_C () =
  print_from_A ();
  print_from_B ();
  Printf.printf ``Ouch! from C:\n %s\n'' x
\end{OCaml}

We use our library into a \texttt{main.ml} file:

\begin{OCaml}
open Ns

let _ = 
  A.print_from_A ();
  B.print_from_B ()
\end{OCaml}

As you can notice, those files are not using the same name as defined in
ns.ml. Now, here is the command line to compile our new namespace and the
program using it. We will explain it step by step:

%% \begin{verbatim}
%% 1) ocamlc -c -no-alias-deps ns.ml
%% 2) ocamlc -c -open Std -o ns_a.cmo -c a.ml
%% 3) ocamlc -c -open Std -o ns_b.cmo -c b.ml
%% 4) ocamlc -c -open Std -o ns_c.cmo -c b.ml
%% 5) ocamlc -a -o ns.cma ns.cmo ns_a.cmo ns_b.cmo ns_c.cmo
%% 6) ocamlc -o prog.byte ns.cma main.ml
%% \end{verbatim}

\begin{verbatim}
$ ocamlc -c -no-alias-deps ns.ml
File "_none_", line 1:
Warning 49: no cmi file was found in path for module Ns_a
File "_none_", line 1:
Warning 49: no cmi file was found in path for module Ns_b
File "_none_", line 1:
Warning 49: no cmi file was found in path for module Ns_c
\end{verbatim}

\texttt{ns.ml} is first compiled using the \texttt{-no-alias-deps} option. The
\texttt{.cmo} can be compiled without even needing the .cmis of Ns\_a, Ns\_b and
Ns\_c, as soon as they can be given at link time \textbf{if they are ever
  used}.

\begin{verbatim}
$ ocamlc -c -open Ns -o ns_a.cmo a.ml
$ ocamlc -c -open Ns -o ns_b.cmo b.ml
$ ocamlc -c -open Ns -o ns_c.cmo c.ml
\end{verbatim}

The three files are compiled, and their result will be the original name
prefixed by ``ns\_''. It matches the names given in \texttt{ns.ml}. One can
notice the \texttt{-open Ns}: it is a trick to be able to refer directly to the
other modules from Ns, and it allows ocamldep not to discover the dependency to
\texttt{ns.cmo}. ocamldep will then look for the ``unprefixed'' sources. 

\begin{verbatim}
$ ocamlc -a -o ns.cma ns.cmo ns_a.cmo ns_b.cmo ns_c.cmo
\end{verbatim}

A library is created for our namespace. It is not mandatory, but it will help to
link only the compilation units that are \emph{strong dependencies}.

\begin{verbatim}
$ ocamlc -c main.ml
$ ocamlc -o prog ns.cma main.cmo
\end{verbatim}

Finally, \texttt{main.ml} is compiled using this namespace.

It does work, but it does not tell too much how it changes the current
behavior. We will compare by creating a namespace without using the
\texttt{-no-alias-deps} option. It simply changes the order of compilation, and
\texttt{-open Ns} won't be usable since it cannot be compiled before the
compilation units it aliases.

\begin{verbatim}
Size of executables generated using -no-alias-deps and -pack:
prog: 16392 bytes.
prog.opt: 199309 bytes.
prog_pack: 127343 bytes.     //only in bytecode

Size of executables generated without -no-alias-deps:
prog: 127399 bytes.
prog.opt: 485852 bytes.
\end{verbatim}

As we can notice, since our main program does not use the module C of
``namespace'' Ns, it is never linked when using \texttt{-no-alias-deps}. We can
notice the difference in terms of size of the generated executables where the
bytecode is almost 8 times bigger without this option (since the \texttt{x}
value in C is a huge string that is statically allocated). We can even notice
that using packs returns the same size of code than without the option.
%% Finally, we compare the usage of \texttt{-pack} in front of \texttt{-no-alias-deps}

Finally, it can be interesting to show what are the dependencies of
\texttt{main.cmo}, to witness the \emph{weak dependencies propagation}. First of
all, here is the result of \texttt{ocamlobjinfo} on the normal behavior:

\begin{verbatim}
$ ocamlobjinfo main.cmo
File main.cmo
Unit name: Main
Interfaces imported:
        32426e00050b7af3f6584864744bd699      Ns
        487292a5ea53b458c1c5ec61282205df      Ns_c
        727f5a710d0c9f793431dc9ad08ec6c0      Printf
        e11a54484508793b436770ce5eab6405      Buffer
        ac02da8b7fc57b7e8f2908c2fe84cb62      Ns_a
        1c68752c7f711d4607125db93919a625      Ns_b
        694c578e10dc06471184517139073079      Pervasives
        179e236b77fab5842aaea6e1f5cf7292      Main
Uses unsafe features: no
Force link: no
\end{verbatim}

And with \texttt{-no-alias-deps}:

\begin{verbatim}
ocamlobjinfo ../main.cmo
File ../main.cmo
Unit name: Main
Interfaces imported:
        abe499d3c0a68d24e12116f354315fd8      Ns_a
        b535a55b20ef3a16e4fe514e82c82238      Ns_b
        32426e00050b7af3f6584864744bd699      Ns
        694c578e10dc06471184517139073079      Pervasives
        179e236b77fab5842aaea6e1f5cf7292      Main
Uses unsafe features: no
Force link: no
\end{verbatim}

We can notice that \texttt{Ns\_c} does not appear as a dependency in the second
case, which explains why it is not linked. It proves how the link is done
according to the next version of OCaml.

This trick can do a minimal job and does not change too much the actual code
base for users that used modules to simulate namespaces (it was actually the
goal of this implementation). However, those bits of namespaces are only on the
build system's side. It lacks extensivity, and functorization can be painful
since every compilation unit has to be encapsulated in a functor. Moreover, it
needs a strong build system to compute the dependencies, and a correct Makefile
can be hard to write according to this namespace strategy. Another point it
doesn't solve is the ability to link two compilation units with the same name
(and try to solve this point by using the new \emph{-o} behavior to add a prefix
at compile time).

In terms of dependencies, using the canonical name (not prefixed) and the
\texttt{-open} to build the dependencies correctly is not that strong. Indeed,
if one uses directly the fully qualified name of the module (for example
\texttt{Ns.A}), ocamldep will not be able to discover the dependency on
\texttt{a.ml}. When using \lstinline{open Ns}, there won't be any problem
however, but using fully qualified modules breaks the trick. 

In another hand, this new alias and weak dependencies semantics is rather
elegant and really helpfull, and can decrease a lot the size of the code.

This solution works thanks to the module aliases (which are no longer only
references), and in fact could be used, but it is complex enough to discourage
beginners to create their own. As a result, since it is rather a trick than a
real solution, we propose our own design that we aim to be clearer, simpler to
use and more expressive.

\section{Semantics in the language}

Namespaces are integrated into the language, they are a meaning to represent
\emph{hierarchies} of modules and namespaces, helping the user to use multiple
modules from different libraries, and possibly with the same name, without using
long-prefixed names or aliases. For the library provider, it allows the
possibility to use simpler names.

Namespaces are not directly used inside the language, but in a prelude of each
module to describe the ``compilation environment''. Only \emph{toplevel modules}
(as compilation unit) can belong to namespaces, not submodules. A namespace is
simply declared: 

%% \begin{figure}[H]
\begin{verbatim}
prelude ::=
    | "in" "namespace" mod_longident imports 
    | imports

implementation ::=
    | prelude structure EOF
    | structure EOF

interface ::=
    | prelude signature EOF
    | signature EOF
\end{verbatim}
%% \caption{Namespace declaration}
%% \end{figure}

This construction allows to declare modules into subnamespaces. The following
example is valid:

\begin{OCaml}
in namespace Inria.Std
\end{OCaml}

%% Namespaces can take arguments, in other words they can abstract some of their
%% implementation and became modular. The argument of the ``functor'' has to be a
%% \texttt{.mli} available in the namespace (in this syntax the module signature is
%% not explicit, it is not clear for now if it shoud be since the mli/cmi is the
%% signature). For now, it is not clear if this argument must be explicit for each
%% modules in the namespace, or only those that uses it. If it has to be explicited
%% (even if unused) in each, the result would be that the interface used to type
%% this argument would also have a ``virtual'' access to it, resulting in a false
%% recursive module.

%% In this proposal, the functorized namespaces are part of the language, not only
%% defined at the build system level (like functor-pack): it is an essential part
%% of our proposal and useful to understand how the namespaces are organized and
%% used.

\medskip

There is actually two possible propositions, with two semantics. The first
imports modules from namespaces directly in the environment. The other imports
the complete path of the module, in other word each modules qualified by their
namespace. The syntax is almost the same, the only difference is
\texttt{ns\_conf} which differs according to our two proposals. 


%% \begin{figure}[H]
\begin{verbatim}
module_name = uident

imports ::=
    | 
    | import imports 

import ::=
    | ("with|"and)" ns_conf                           module importation    

// for the first proposal
ns_conf ::=
    | "(" modules_constraints ")" "of" mod_long_ident 
                                                      modules constraints

// for the second proposal
ns_conf ::=
    | mod_long_ident "." "(" module_constraints ")"

modules_constraints ::=
    | module_constraint
    | module_constraint ";" module_constraints

modules_constraint ::=
    | "_"                                             "wildcard": every other modules
    | module_name "as" module_name                    aliased module
    | module_name "as" "_"                            shadowed module
    | module_name                                     a module
\end{verbatim}
%% \caption{Namespace use}
%% \end{figure}

\paragraph{First proposal}

The syntax is rather simple, and can be simply described. The imports allows the
user to declare which modules to use from this namespace. The wildcard allows to
import in the environment every modules of the namespace that are not declared
in the current constraints. Shadowing doesn't add the module (it is only useful
when using the wildcard), and aliasing allows to have module from multiple
namespace with the same original name.

Importing a namespace does not import the subnamespaces. Being in a namespace
allows to directly import every modules from it. Modules without namespaces are
accepted and virtually doesn't belong to one. Actually, there is a \emph{global}
namespace (like C\# of F\#) for this specific issues.

\paragraph{Second proposal}

On the contrary, modules are not directly imported in the environment. The
complete path is accessible, and the namespaces can be used as modules (with
some restrictions). In this idea, namespaces are kind of modules, and have a
signature. In fact, this implementation does an elaboration of the import
clauses into multiple modules and sub modules.

In both propositions, namespace and modules share the same ``namespace'' (i.e.,
a namespace cannot have the same name as a module, and vice-versa).

The possibilities inside the language are simple, but there are some possible
extensions that will be discussed later.

\section{Compilation}

\paragraph{Dependencies}

The dependency computation would not change too much and would be helped thanks
to the header. This would allow to retrieve the namespace of each module (except
when using the wildcard import, which is trickier without having knowledge of
the existing namespaces available in the program).

This wildcard issue is only relevant in the case we want namespaces to be given
along with modules' name with the option \texttt{-modules}. It can be solved by
simply changing the behavior of the existing algorithm. For now, asking for raw
dependencies simply prints the modules that are used, without even looking for
the corresponding \texttt{.ml(i)} files in the loadpath. What is proposed is
using the normal behavior and check if a file exists when a namespace cannot be
derived, checking if files that corresponds uses one namespace from the imports
(that only use wildcards). It can refine the dependencies of the compiled
program, and let the build system deal with modules whose namespaces aren't
found (because they belong to external libraries that are linked with the
program). This algorithm would be used however in the original ocamldep's
behavior, when looking for the .ml in the loadpath: when namespace cannot be
resolved, each file in the loadpath with the same name as the module is checked
to possibly retrieve one that belongs to a namespace imported with wildcard. It
can be an option of ocamldep, and it will simply read the first three tokens of
the files that could match to retreive the namespace.


\paragraph{Compilation unit}

Since namespaces allows the possibility of modules with the same name to be
linked together, internal name must be extended to be a long name, which is simply
using the namespace as a prefix. It is done in the .cmi files, allowing ocamlc
and ocamlopt both be able to use this information. The prefix can be the
namespace and maybe some other information, like a version information: it would
allow to link two versions of the same library in the same program. A use case
of such a feature could be for debugging features that have been rewritten
between two versions, or simply benchmarking a new version against the old one.


\paragraph{Linking} We will suppose for now that linking is simply giving a name
of a library (or a path), without bothering for looking how are organized those
libraries on the filesystem. It will be explained in the next section.

An important property of namespaces is they are \emph{extensible}, meaning that
anyone can add a module to an existing namespace. In other words, linking two
libraries that exports the same namespaces will \emph{merge} them into
one. Actually, it is the current behavior during link with modules: if two
modules have the same name in the loadpath, only the first one found (according
to the order of -I given to the compiler) is used (see formula (\ref{merge}). In
our merge semantics, we follow the same rules: when two namespaces have the same
name, the result is a namespace that contains the modules from both, and in case
of conflicting modules only the first one found are kept.

A formal representation is the following: suppose the loadpath $LP$, which
contains paths $P_i$. Each path $P_i$ is a directory that contains compilation
units $C_j$ and directories $D_k$. Then, the compilation units are:

\begin{multline}
\forall D_1, D_2 \in P_1, P_2, D_1 = D_2
\rightarrow P_1 \oplus' P_2 = P_1 \oplus P_2 + D_1 \oplus D_2
\label{ns-merge} 
\end{multline}

It is a recursive definition, meaning that subfolders are also taking in
consideration. As a result $\oplus$ is replaced by $\oplus'$ when computing the
available compilation units.

For example, we can consider the two following libraries:

\begin{verbatim}
(* "global" is the root namespace *)

(* For stdlib *)
global ---- Std ---- List
                  |- Hashtbl
                  |- ...

(* For ocamlpro *)
global ---- Std ---- List
         |- ...   |- Utils
                  |- ...
\end{verbatim}
and we suppose the library \emph{ocamlpro} is linked using \texttt{-I +ocamlpro}.

\texttt{stdlib} is always linked last, meaning that any libraries using the
\texttt{``global''.Std} namespace would conflict with it. The result is that the
modules in \texttt{Ocamlpro/Std} would subsume those existing with the same name
from the standard library. If one use \texttt{List} in its program, it would be
the one from OCamlPro. But modules that do not not exists in
\texttt{Ocamlpro/Std} are still accessible.


\paragraph{Parametric namespaces}

\textbf{Work-in-progress}

Namespaces can be parametric and use multiple implementations over one
interface. A module can be abstracted and considered as a \emph{parameter} in
the namespace. 

The actual functor pack patch adds two fields to cmis/cmos/cmxs:
\lstinline{functor_part} and \lstinline{functor_args}. They can certainly be
reused for modules that belong in such a namespace. It will be completely
explicit in the build system. For example, let assume a namespace \texttt{Ns}
which is parametric over an interface \texttt{Arg}. Its modules are compiled
with the option 

\begin{verbatim}
ocamlc -functor arg.cmi a.ml
\end{verbatim}

We can then instantiate them by applying them an argument, which would result on
a new namespace that corresponds of the applied version on this specific
argument. Instantiating the modules would lead to 

\begin{verbatim}
ocamlc -apply x.cmo -ns NsX a.cmo 
(* the namespace has to be given as an option since there does not exists a
 source file for the original *)
\end{verbatim}

As a result, the instantiation is done once and for all. This would introduce a
concept of ``functor-units''.

\section{Installation and file system relationship}

One of the advantage of namespaces is their ability to provide a nice way to
define how libraries are installed and how the compiler should look for the
modules. As a result, we can leverage the need for external tools to compile
using external libraries, especially for simple programs.

\paragraph{Compiled modules and installation}

Namespaces and file system organization are highly related: a namespace is a
directory, at least after compilation (it has been hinted in (\ref{ns-merge})
actually). For example, if the module belongs to the namespace
\texttt{Inria.Std}, its compilation result will be placed in the directory
\texttt{inria/std}. As a result, the compiler will be able to look for modules
in namespaces and subnamespaces simply by scanning recursively the folders in
its loadpath. Sources should belong to the same directory, and it could help
ocamldep to look for dependencies without having to check the ``in namespace''
declaration. However, it can be avoided, and the compiler will create the
correct directories thanks to the ``in namespace'' information.

When linking, those folders are looked for from the loadpath: there is not a
global folder where modules from different libraries are placed. It would be
quite hard to link a library since the compiler would have to look for each
modules that belongs to that library. Moreover, installing a library that
extends a namespace and redefines some of its existing modules would be clearly
dangerous, and could lead to overwriting files.

To allow those namespaces to be used without external tool, we propose to add a
canonical path where libraries should be installed, which would be symbolized by
``+'' before the folder name with \texttt{-I}. This path can be set by an
environment variable of the system (\texttt{OCAML\_LD\_PATH} for
example). Linking a library is simply giving the folder where it is installed to
\texttt{-I}. Modules that doesn't have a namespace can be found at the root of
the loadpath. Another possibility is to use an option \texttt{-lib} to refer to
libraries stored in the canonical install path: it would not change the \texttt{-I}
behavior.

Having such a standard library path for user libraries is relevant, thanks to
the use of OPAM: the user's libraries are installed in the
\texttt{~/.opam/<version>/lib/} directory, and it can be used as a standard
installation path. 

\paragraph{Alternative to hierarchical filesystem}

Whereas file system is a good way to organize namespaces, some could want a way
to flatten this hierarchy to avoid scanning (it can be too slow on some
operating system). The idea is to provide a file (\texttt{.ns}) that simply
describes where are the files of the library, and in which namespace they
belong. It has the following simple syntax:

\begin{verbatim}
lines ::=
    | EOF
    | line "\n" lines EOF

line ::= filepath ":" mod_longident
\end{verbatim}

The compiler can create this file during compilation, or we can imagine a simple
program (\emph{ocamlns}) which would read the namespace information of each file
to create this \texttt{.ns}. It would be available at the root of each installed
libraries (in each -I added folder) and read by the compiler.


\section{Others concerns and future extensions}

\paragraph{-pack with namespace}

The problem namespaces resolves is the -pack issue, however some would still
want to use both in a program. In that case, the packing result maybe could have
a namespace. The behavior is then:
\begin{itemize}
\item if every modules to be packed are in the same namespace, then the
  ``package'' is in the same.
\item if namespaces are different, -pack fails.
\end{itemize}

In this constraints, the -pack is backward compatible since modules without
namespaces doesn't belong to a namespace at all (at least virtually).

\paragraph{-functor-pack with namespaces}

The rules are the same as with -pack: the \emph{big functor} belongs to the same
namespace as its functors packed.

\paragraph{Automatically opened modules}

Namespaces can be an elegant way to declare libraries. We can suppose a library
wants one of its modules is always opened when using it, ``Ã -la''
Pervasives. A possibility would be to open automatically modules whose name is
Pervasives when using a namespace. It binds the name to a specific semantics,
but is relevant since some languages binds the \emph{main} name as the entry
point of a program.

%% It
%% would be syntactically easy to add such a feature, by adding the keyword
%% ``opened'' at the beginning of the namespace declaration, but it needs more
%% thoughts at compilation and linking. There are some way to do it, especially by
%% adding a directory \texttt{``\_opened''} in the installed library for each
%% namespaces with such modules, that the compiler would recognize as the
%% automatically opened ones. As a result, when importing a library (even one
%% module), the opened ones are automatically imported. Aliasing or shadowing
%% them prevent this behavior.

%% This proposition is part of the 4.02 version of OCaml: a \texttt{-open} option
%% had been added, what we propose is specifying modules that should be opened
%% directly in the language, making this option automatic when using the namespace.

\section{Use-case}

We present some use cases of namespaces in the language, at first with the first
proposal, then with the second one, showing what is interesting with both proposal.

\subsection{Extending libraries}

Namespaces are extensible, in other words, one can add any module in it. It can
be useful to extend the standard library, or replacing some modules with an
implementation more efficient. We suppose the standard OCaml library belongs to
the namespace Inria.Std (we suppose its modules are automatically
imported).

\begin{OCaml}
(** hashset.ml *)
in namespace Inria.Std
...
\end{OCaml}

\begin{OCaml}
(** string.ml, a replacement for the original String module *)
in namespace Inria.Std

(* we need to first alias the original String *)
  with (String -> S) of Inria.Std

include S

(* some new functions and rebindings of String *)
...
\end{OCaml}

Supposing this extended library is installed into \texttt{+extendedlib}, the
compilation of a program M using it is simply:
\begin{verbatim}
ocaml(c|opt) -o prog -I +extendedlib m.ml
\end{verbatim}

Of course, the String module we've defined is not used by the modules from the
``original'' namespace but only by our extended version.

\subsection{Parameterized library}

Suppose we're writing a library that uses a specific asynchronous monad, like
Lwt, but without without specifying implementation, leaving the choice up to the
user. Suppose this library is an implementation for the HTTP protocol. The modules
from this library resides in the namespace Mylib.Http. Protocol is the main module.

\begin{OCaml}
(** async_monad.mli *)
in namespace Mylib.Http

type t

val (>>=) : 'a t -> ('a -> 'b t) -> 'b t

val return : 'a -> 'a t
val bind : 'a t -> ('a -> 'b t) -> 'b t (* == (>>=) *)
val poll : 'a t -> 'a option
...
\end{OCaml}

\medskip

\begin{OCaml}
(** protocol.ml *)

in namespace MyLib.Http

open Async_monad
...
\end{OCaml}

The compilation of our module is:

\begin{verbatim}
ocamlc -c -functor Async_monad protocol.ml
\end{verbatim}

\medskip

Now suppose your writing a server, using this HTTP library (we suppose it
belongs to a namespace Myserver). First of all, we have to instantiate our
namespace over an implementation of our monad:

\begin{verbatim}
ocamlc -I +ocsigen-lib -apply Ocsigen.Lwt -ns Mylib.Http_Lwt protocol.cmo
... # We do the same for the other modules in this namespace 
\end{verbatim}

We then create a new namespace Mylib.Http\_Lwt that corresponds to the
instantiation of Mylib.Http over Ocsigen.Lwt.

\begin{OCaml}
(** main_lwt.ml *)
in namespace Myserver
  with (Lwt) of Ocsigen
  and (Protocol) of MyLib.Http_Lwt
...
\end{OCaml}

\subsection{Multiple instantiation}

Suppose a library using a SAT-solver to prove the correctness of some values it
is using. There exists multiple SATisfiability solving algorithms (mainly DPLL
and CDCL, with multiple variants), and one case of functors at the namespace
level would be to instantiate multiple versions of a library and benchmark the
different implementations.

Suppose our library, particularly composed by a \emph{hole} Sat and a module
Solver. The library defines its namespace MySolver.

\begin{OCaml}
(** sat.mli *)
in namespace MySolver

type bnf

val solve: bnf -> bool
\end{OCaml}

\medskip 

\begin{OCaml}
(** solver.ml *)
in namespace MySolver

let is_sat f =
... 
(* some preliminary computations, like turning the formula into its bnf *)
  let sat = Sat.solve formula in 
...
\end{OCaml}

\begin{verbatim}
ocamlc -c sat.mli
ocamlc -c -functor Sat solver.ml
\end{verbatim}

\medskip

Finally, our Solver can be used by the following benchmarking modules:

\begin{verbatim}
ocamlc -apply Dpll -ns MySolver_Dpll solver.cmo
... # every other modules to instantiate

ocamlc -apply Cdcl -ns MySolver_Cdcl solver.cmo
... # idem 
\end{verbatim}

\begin{OCaml}
(** bench.ml *)
with (Parser, Solver as Solve_Dpll) of MySolver_Dpll
and (Solver as Solve_Cdcl) of MySolver_Cdcl

...
let compute_and_print_time l = ...
...

let () =
  let formulas = 
    Parser.open_read_and_parse Sys.argv.[1] in
  let eval f =
    let t1 = Sys.time () in
    ignore (Solve_Dpll.is_sat f);
    let t2 = Sys.time () in
    ignore (Solve_Cdcl.is_sat f);
    let t3 = Sys.time () in
    (t2 - t1, t3 - t2)
  in
  let times = List.map eval formulas in
  compute_and_print_time times
\end{OCaml}

\medskip



%% \bibliographystyle{abbrv}
%% \bibliography{biblio} 

\end{document}
