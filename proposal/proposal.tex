\documentclass[11pt,a4paper]{article}

\usepackage{verbatim}
\usepackage[english]{babel}
%% \usepackage{float}
\usepackage{listings}
\usepackage[utf8]{inputenc}

\lstnewenvironment{OCaml}
                  {\lstset{
                      language=[Objective]Caml,
                      breaklines=true,
                      %% commentstyle=\color{purple},
                      %% stringstyle=\color{red},
                      %% identifierstyle=\ttfamily,
                      %% keywordstyle=\color{blue},
                      basicstyle=\footnotesize\tt,
                      otherkeywords={namespace, abstract}
                    }
                  }
                  {}

% Fourth revision

\title{Namespaces for OCaml - Proposal}

\begin{document}

\maketitle

This proposal is about integrating namespaces into the OCaml language, but
without changing the semantics of the language and cluttering it. It aims to be
rather independent from the core language and viewed as a meaning for the user to
describe its compilation environment, and helping the compiler without the need
of external tools for simple compilation.

It tightly binds the build system, the file system and the language together,
helping the compiler to reason about installed libraries.
It focuses on the following points:
\begin{itemize}
\item Semantics in the language
\item Compilation according to namespaces
\item Installation and linking of libraries
\end{itemize}

What we want to solve in particular is integrating the \emph{big-functor} patch
at the namespace level, allowing to have paramteric libraries. At the end, we
present some use case of namespaces.

One particular goal we want to achieve is making a clear distinction between the
language's semantics and the code generation, in other word making the language
more expressive, especially in cases like -pack and -pack-functor, which are
defined in the build system but are part of the code.

An option had been added then, thanks to ``module aliases'', to avoid linking
necessity when an alias in unused, which simulates a namespace
mechanism. However, it remains an option of the compiler (which is not a
feature, otherwise it would be activated by default).

Our namespaces proposal aims to solve this issue by designing real namespaces,
with a particular semantics, without using modules to simulate them and using
``hacks'' in the compiler to avoid unused linking.

\section{Namespaces in OCaml: state of the art}

In the current stable version (4.01.0), there is no namespace solution. The only
possibility is aliasing modules into one. However, the result is a huge
\texttt{.cmo} that contains every aliased one, because the alias is in fact a
copy, not a reference. In the next version (4.02.0), module aliases have been
improved, and new options added to the compiler.

First of all was added the \emph{real} module aliases. As a result, it decreases
a lot the size of the compiled code since it is no longer equivalent to
\texttt{module X = struct include Y end}: it only is a reference now. This
feature was needed since some library providers (Jane Street's Core in
particular) used that kind of construction to simulate namespaces: a single
module which essentially contains only aliases, which avoids using long names
for the user but qualification and opening the ``big module''. For Core, it
would create one huge compilation unit, resulting in linking every modules
aliased (and aliases in those ones, etc).

With this new semantics has been introduces a new option: \texttt{-no-alias-deps},
that allow unused aliases to be dropped at link time, and moreover, that allows
the .cmi of those aliases not to be present yet. Another option added is the
\texttt{-open}, which allows modules to be opened before compiling. It simply adds
the opening statement at the beginning of the AST. Finally, the \texttt{-o} has
been modified: the compilation unit name is now the same as the filename given
to the option (actually, only the left part before the first ``.'').

Using those features, it is possible to simulate some kind of ``namespaces'' in
OCaml. Here is a complete example of how it works.

We are going to make a namespace Std, which would contain two modules Array and
List. Then Std is simply a module that contains only aliases (the code of this
example is available in the same repository as this proposal):

\begin{OCaml}
(* std.ml *)

module List = Std_list
module Array = Std_array
\end{OCaml}

Then, we define our two modules:

\begin{OCaml}
(* list.ml *)

type 'a t = 'a list
...

(* array.ml *)
type 'a t = 'a List.t 
...
\end{OCaml}

We use our library into a \texttt{main.ml} file:

\begin{OCaml}
open Std

let _ = ...
\end{OCaml}

As you can notice, those files are not using the same name as defined in
std.ml. Now, here is the command line to compile our new namespace. We will
explain line by line:

\begin{verbatim}
1) ocamlc -c -no-alias-deps std.ml
2) ocamlc -c -no-alias-deps -open Std -o std_list.cmo -c list.ml
3) ocamlc -c -no-alias-deps -open Std -o std_array.cmo -c array.ml
4) ocamlc -a -o std.cma std.cmo std_list.cmo std_array.cmo
5) ocamlc -o prog.byte std.cma main.ml
\end{verbatim}

\begin{enumerate}
\item \texttt{std.ml} is first compiled using the -no-alias-deps option. The
  .cmo can be compiled without even needing the .cmis of Std\_list and
  Std\_array (as soon as they can be given at link time).
\item \texttt{list.ml} is compiled into \texttt{std\_list.cmo}. Its compilation
  unit name is then \lstinline{Std_list}. As you can notice, Std is opened, but
  we do not use it there.
\item \texttt{array.ml} is compiled into \texttt{std\_array.cmo}. Std is opened:
  it simulates the fact that Array is part of Std, and then can access
  ``Std\_list'' as ``List'' directly.
\item A library is created for our namespace (it is not mandatory however).
\item Finally, \texttt{main.ml} is compiled using this namespace.
\end{enumerate}

One problem we can notice is it introduces a false circularity thanks to
-no-alias-deps (which still gives a warning if no .cmi is present for the
alias). One can wonder why list.ml and array.ml are not directly prefixed: it
allows \texttt{ocamldep} to compute the correct dependencies. Since it does not
use the \texttt{-open}, it will directly look for \texttt{list.ml} and
\texttt{array.ml} when computing dependencies.

This trick can do a minimal job and does not change too much the actual code
base for users that used modules to simulate namespaces. However, those bits of
namespaces are only on the build system's side, and not easily compiled using
GNU Make. It also lacks extensivity, and functorization can be painful since
every compilation unit has to be encapsulated in a functor. As a result, since
it is rather a trick than a real namespace solution, we propose our own design
that we aim to be clearer, simpler to use and more expressive.

\section{Semantics in the language}

Namespaces are integrated into the language, they are a meaning to represent
\emph{hierarchies} of modules and namespaces, helping the user to use multiple
modules from different libraries, and possibly with the same name, without using
long-prefixed names or aliases. For the library provider, it allows the
possibility to use simpler names.

Namespaces are not directly used inside the language, but in a prelude of each
module to decribe the ``compilation environment''. Only \emph{toplevel modules}
(as compilation unit) can belong to namespaces, not submodules. A namespace is
simply declared: 

%% \begin{figure}[H]
\begin{verbatim}
ns_args ::=
    | 
    | "(" module_name ")" ns_args

implementation ::=
    | "in" "namespace" mod_longident ns_args headers structure EOF
    | headers structure EOF
    | structure EOF

interface ::=
    | "in" "namespace" mod_longident ns_args headers signature EOF
    | headers signature EOF
    | signature EOF
\end{verbatim}
%% \caption{Namespace declaration}
%% \end{figure}

This construction allows to declare modules into subnamespaces. The following
example is valid:

\begin{OCaml}
in namespace Inria.Std
\end{OCaml}

Namespaces can take arguments, in other words they can abstract some of their
implementation and became modular. The argument of the ``functor'' has to be a
.mli available in the namespace (in this syntax the module singature is not
explicit, it is not clear for now if it shoud be). For now, it is not clear if
this argument must be explicit for each modules in the namespace, or only those
that uses it. If it has to be explicited (even if unused) in each, the result
would be that the interface used to type this argument would also have a
``virtual'' access to it, resulting in a false recursive module.

In this proposal, the functorized namespaces are part of the language, not only
defined at the build system level (like functor-pack): it is an essential part
of our proposal and useful to understand how the namespaces are organized and
used.

\medskip

As in other languages, namespaces are imported, and its modules added into the
environment. Namespaces cannot be used to qualify modules. The syntax, which can
change and is only a representation of the possibilities, is the following:

%% \begin{figure}[H]
\begin{verbatim}
module_name = uident

imports ::=
    | 
    | import imports 

import ::=
    | ("with|"and)" ns_conf                           module importation    

ns_conf ::=
    | "(" modules_constraints ")" "of" mod_long_ident 
                                                      modules constraints
    | "(" modules_constraints ")" "of" mod_long_ident ns_args 
                                                      namespaces instantiation 

modules_constraints ::=
    | module_constraint
    | module_constraint ";" module_constraints

modules_constraint ::=
    | "_"                                             every other modules
    | module_name "as" module_name                    aliased module
    | module_name "as" "_"                            shadowed module
    | module_name                                     a module
\end{verbatim}
%% \caption{Namespace use}
%% \end{figure}

The syntax is rather simple, and can be simply described. The imports allows the
user to declare which modules to use from this namespace. The wildcard allows to
import in the environment every modules of the namespace that are not declared
in the current constraints. Shadowing doesn't add the module (it is only useful
when using the wildcard), and aliasing allows to have module from multiple
namespace with the same original name.

Importing a namespace does not import the subnamespaces. Being in a namespace
allows to directly import every modules from it. Modules without namespaces are
accepted and virtually doesn't belong to one. Actually, there is a \emph{global}
namespace (like C\# of F\#) for this specific issues.

A namespace can be imported and instantiated over some implementation. It allows
parametric libraries, and will be explained in the compilation section. 

The possibilities inside the language are simple, but there are some possible
extensions that will be discussed later.

\section{Compilation}

\paragraph{Dependencies}

The dependency computation would not change too much and would be helped thanks
to the header. This would allow to retrieve the namespace of each module (except
when using the wildcard import, which is trickier without having knowledge of
the existing namespaces available in the program).

This wildcard issue is only relevant in the case we want namespaces to be given
along with modules' name with the option \texttt{-modules}. It can be solved by
simply changing the behavior of the existing algorithm. For now, asking for raw
dependencies simply prints the modules that are used, without even looking for
the corresponding .ml(i) file in the loadpath. What is proposed is using the
normal behavior and check if a file exists when a namespace cannot be derived,
checking if files that corresponds uses one namespace from the imports (that
only use wildcards). It can refine the dependencies of the compiled program, and
let the build system deal with modules whose namespaces aren't found (because
they belong to external libraries that are linked with the program). This
algorithm would be used however in the original ocamldep's behavior, when
looking for the .ml in the loadpath: when namespace cannot be resolved, each file
in the loadpath with the same name as the module is checked to possibly retrieve
one that belongs to a namespace imported with wildcard.


\paragraph{Compilation unit}

Since namespaces allows the possibility of modules with the same name to be
linked together, internal name must be extended to be a long name, which is simply
using the namespace as a prefix. It is done in the .cmi files, allowing ocamlc
and ocamlopt both be able to use this information. The prefix can be the
namespace and maybe some other information, like a version information: it would
allow to link two versions of the same library in the same program. A use case
of such a feature could be for debugging features that have been rewritten
between two versions, or simply benchmarking a new version against the old one.


\paragraph{Linking} We will suppose for now that linking is simply giving a name
of a library (or a path), without bothering for looking how are organized those
libraries on the filesystem. It will be explained in the next section.

An important property of namespaces is they are \emph{extensible}, meaning that
anyone can add a module to an existing namespace. In other words, linking two
libraries that exports the same namespaces will \emph{merge} them into
one. Actually, it is the current behavior during link with modules: if two
modules have the same name in the loadpath, only the first one found (according
to the order of -I given to the compiler) is used. In our merge semantics, we
follow the same rules: when two namespaces have the same name, the result is a
namespace that contains the modules from both, and in case of conflicting
modules only the first one found are kept.

For example, we can consider the two following libraries:

\begin{verbatim}
(* "global" is the root namespace *)

(* For stdlib *)
global ---- Std ---- List
                  |- Hashtbl
                  |- ...

(* For ocamlpro *)
global ---- Std ---- List
         |- ...   |- Utils
                  |- ...
\end{verbatim}
and we suppose the library \emph{ocamlpro} is linked using \texttt{-I +ocamlpro}.

\texttt{stdlib} is always linked, meaning that any libraries using the
\texttt{``global''.Std} namespace would conflict with it. The result is that the
modules in \texttt{Ocamlpro/Std} would subsume those existing with the same name
from the standard library. If one use \texttt{List} in its program, it would
be the one from OCamlPro. But modules that don't belong to \texttt{Ocamlpro/Std}
are still accessible.


\paragraph{Parametric namespaces}

\textbf{Work-in-progress}

Namespaces can be parametric and use multiple implementations over one
interface. A module can be abstracted and considered as a \emph{parameter} in
the namespace. 

The actual functor pack patch adds two fields to cmis/cmos/cmxs:
\lstinline{functor_part} and \lstinline{functor_args}. They can certainly be
reused for modules that belong in such a namespace. We can imagine a mechanism
that then instantiate those modules with the structure given, for example by
defining a .cmn that would act as the ``functor'' of the namespace (I don't have
any idea how for now).

Compiling a module which belongs to a paramteric namespace is using the
\lstinline{-functor} automatically, feeding with the correct cmi. 

\section{Installation and file system relationship}

One of the advantage of namespaces is their ability to provide a nice way to
define how libraries are installed and how the compiler should look for the
modules. As a result, we can't leverage the need for external tools to compile
using external libraries, especially for simple programs.

\paragraph{Compiled modules and installation}

Namespaces and file system organization are highly related: a namespace is a
directory, at least after compilation. For example, if the module belongs to the
namespace \texttt{Inria.Std}, its compilation result will be placed in the
directory \texttt{inria/std}. As a result, the compiler will be able to look for
modules in namespaces and subnamespaces simply by scanning recursively the
folders in its loadpath. Sources should belong to the same directory, and it
could help ocamldep to look for dependencies without having to check the ``in
namespace'' declaration. However, it can be avoided, and the compiler will
create the correct directories thanks to the ``in namespace'' information.

When linking, those folders are looked for from the loadpath: there is not a
global folder where modules from different libraries are placed. It would be
quite hard to link a library since the compiler would have to look for each
modules that belongs to that library. Moreover, installing a library that
extends a namespace and redefines some of its existing modules would be clearly
dangerous, and could lead to overwriting files.

To allow those namespaces to be used without external tool, we propose to add a
canonical path where libraries should be installed, which would be symbolized by
``+'' before the folder name with \texttt{-I}. This path can be set by an
environment variable of the system (\texttt{OCAML\_LD\_PATH} for
example). Linking a library is simply giving the folder where it is installed to
\texttt{-I}. Modules that doesn't have a namespace can be found at the root of
the loadpath.

Having such a standard library path for user libraries is relevant, thanks to
the use of OPAM: the user's libraries are installed in the
\texttt{~/.opam/<version>/lib/} directory, and it can be used as a standard
installation path. 

\paragraph{Alternative to hierarchical filesystem}

Whereas file system is a good way to organize namespaces, some could want a way
to flatten this hierarchy to avoid scanning (it can be too slow on some
operating system). The idea is to provide a file (\texttt{.ns}) that simply
describes where are the files of the library, and in which namespace they
belong. It have the following simple syntax:

\begin{verbatim}
lines ::=
    | EOF
    | line "\n" lines EOF

line ::= filepath ":" mod_longident
\end{verbatim}

The compiler can create this file during compilation, or we can imagine a simple
program (\emph{ocamlns}) which would read the namespace information of each file
to create this \texttt{.ns}. It would be available at the root of each installed
libraries (in each -I added folder) and read by the compiler.


\section{Others concerns and future extensions}

\paragraph{-pack with namespace}

The problem namespaces resolves is the -pack issue, however some would still
want to use both in a program. In that case, the packing result maybe could have
a namespace. The behavior is then:
\begin{itemize}
\item if every modules to be packed are in the same namespace, then the
  ``package'' is in the same.
\item if namespaces are different, -pack fails.
\end{itemize}

In this constraints, the -pack is backward compatible since modules without
namespaces doesn't belong to a namespace at all (at least virtually).

\paragraph{-functor-pack with namespaces}

The rules are the same as with -pack: the \emph{big functor} belongs to the same
namespace as its functors packed.

\paragraph{Automatically opened modules}

Namespaces can be an elegant way to declare libraries. We can suppose a library
wants one of its modules is always opened when using it, ``Ã -la'' Pervasives. It
would be syntactically easy to add such a feature, by adding the keyword
``opened'' at the beginning of the namespace declaration, but it needs more
thoughts at compilation and linking. There are some way to do it, especially by
adding a directory \texttt{``\_opened''} in the installed library for each
namespaces with such modules, that the compiler would recognize as the
automatically opened ones. As a result, when importing a library (even one
module), the opened ones are automatically imported. Aliasing or shadowing
them prevent this behavior.

This proposition is part of the 4.02 version of OCaml: a \texttt{-open} option
had been added, what we propose is specifying modules that should be opened
directly in the language, making this option automatic when using the namespace.

\section{Use-case}

\subsection{Extending libraries}

Namespaces are extensible, in other words, one can add any module in it. It can
be useful to extend the standard library, or replacing some modules with an
implementation more efficient. We suppose the standard OCaml library belongs to
the namespace Inria.Std (we suppose its modules are automatically
imported).

\begin{OCaml}
(** hashset.ml *)
in namespace Inria.Std
...
\end{OCaml}

\begin{OCaml}
(** string.ml, a replacement for the original String module *)
in namespace Inria.Std

(* we need to first alias the original String *)
  with (String -> S) of Inria.Std

include S

(* some new functions and replacements for String *)
...
\end{OCaml}

Supposing this extended library is installed into \texttt{+extendedlib}, the
compilation of a program M using it is simply:
\begin{verbatim}
ocaml(c|opt) -o prog -I +extendedlib m.ml
\end{verbatim}

Of course, the String module we've defined is not used by the modules from the
``original'' namespace but only by our extended version.

\subsection{Parameterized library}

Suppose we're writing a library that uses a specific asynchronous monad, like
Lwt, but without without specifying implementation, leaving the choice up to the
user. Suppose this library is an implementation for the HTTP protocol. The modules
from this library resides in the namespace Mylib.Http. Protocol is the main module.

\begin{OCaml}
(** async_monad.mli *)
in namespace Mylib.Http(Async_monad)

type t

val (>>=) : 'a t -> ('a -> 'b t) -> 'b t

val return : 'a -> 'a t
val bind : 'a t -> ('a -> 'b t) -> 'b t (* == (>>=) *)
val poll : 'a t -> 'a option
...
\end{OCaml}

\medskip

\begin{OCaml}
(** protocol.ml *)

in namespace MyLib.Http(Async_monad)

...
\end{OCaml}

\medskip

Now suppose your writing a server, using this HTTP library (we suppose it belongs
to a namespace Myserver):

\begin{OCaml}
(** main_lwt.ml *)
in namespace Myserver
  with (Lwt) of Ocsigen
  and (Protocol) of MyLib.Http(Lwt)
...
\end{OCaml}

The program is then instantiated over Lwt, and there can be multiple servers for
each possible asynchronous monad that implements the same interface.

\subsection{Multiple instantiation}

Suppose a library using a SAT-solver to prove the correctness of some values it
is using. There exists multiple SATisfiability solving algorithms (mainly DPLL
and CDCL, with multiple variants), and one case of using ``holes'' would be to
instantiate multiple versions of a library and benchmark the different
implementations.

Suppose our library, particularly composed by a \emph{hole} Sat and a module
Solver. The library defines its namespace MySolver.

\begin{OCaml}
(** sat.mli *)
in namespace MySolver(Sat)

type bnf

val solve: bnf -> bool
\end{OCaml}

\medskip 

\begin{OCaml}
(** solver.ml *)
in namespace MySolver(Sat)

let is_sat f =
... 
(* some preliminary computations, like turning the formula into its bnf *)
  let sat = Sat.solve formula in 
...
\end{OCaml}

\medskip

Finally, our Solver can be used by the following benchmarking module:

\begin{OCaml}
(** bench.ml *)
with (Parser, Solver as Solve_Dpll) of MySolver(Dpll)
and (Solver as Solve_Cdcl) of MySolver(Cdcl)

...
let compute_and_print_time l = ...
...

let () =
  let formulas = 
    Parser.open_read_and_parse Sys.argv.[1] in
  let eval f =
    let t1 = Sys.time () in
    ignore (Solve_Dpll.is_sat f);
    let t2 = Sys.time () in
    ignore (Solve_Cdcl.is_sat f);
    let t3 = Sys.time () in
    (t2 - t1, t3 - t2)
  in
  let times = List.map eval formulas in
  compute_and_print_time times
\end{OCaml}

\medskip

As a result, we can see namespaces with holes as functorized namespaces. Of
course, this example could be done simply by functorizing directly Solver, but
it can be rather nice to let the linker do the job, and it allows every modules
in the namespace to be abstract over this specific interface.

%% \bibliographystyle{abbrv}
%% \bibliography{biblio} 

\end{document}
